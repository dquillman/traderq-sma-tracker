# TraderQ — SMA 20/200 Tracker (Stocks + Crypto)
# v1.4.0
# Single-file Streamlit app with clean SMA logic, pretouch screener, cross markers,
# crypto fallback, and trend chips (Bullish/Bearish) without emoji.

from __future__ import annotations
import math
import time
from datetime import date, datetime, timedelta
from functools import lru_cache

import numpy as np
import pandas as pd
import plotly.graph_objects as go
import streamlit as st
st.set_page_config(page_title="TraderQ SMA 20/200", page_icon="ðŸ“ˆ", layout="wide")

# === PRO_CSS_v170_START ===
import plotly.io as pio

# Dark/Light toggle in sidebar
if "dark_mode" not in st.session_state:
    st.session_state.dark_mode = True
with st.sidebar:
    st.markdown("### Appearance")
    st.session_state.dark_mode = st.toggle("Dark mode", value=st.session_state.dark_mode)

# Plotly theme
pio.templates.default = "plotly_dark" if st.session_state.dark_mode else "plotly_white"

# Neon / glass CSS
st.markdown(
    f'''
    <style>
    :root {{
      --bg: {'#0b1020' if st.session_state.dark_mode else '#ffffff'};
      --card: {'#11162a' if st.session_state.dark_mode else '#ffffff'};
      --text: {'#e8ecf3' if st.session_state.dark_mode else '#111827'};
      --muted: {'#a6b0c3' if st.session_state.dark_mode else '#6b7280'};
      --accent: #6ae3ff;
      --good: #26d07c;
      --bad: #ff6b6b;
      --border: {'#20263d' if st.session_state.dark_mode else '#e5e7eb'};
      --glow: 0 0 24px rgba(106,227,255,.35), 0 0 48px rgba(106,227,255,.15);
    }}
    .stApp {{ background: var(--bg); color: var(--text); font-family: Inter, Segoe UI, system-ui, -apple-system, Roboto, Arial, sans-serif; }}

    /* Top header bar */
    .traderq-nav {{
      position: sticky; top: 0; z-index: 999;
      display:flex; align-items:center; justify-content:space-between; gap:16px;
      padding: 14px 18px; margin: -1rem -1rem 1rem;
      background: linear-gradient(180deg, rgba(20,28,50,.95), rgba(20,28,50,.75));
      border-bottom: 1px solid var(--border);
      box-shadow: var(--glow);
      backdrop-filter: blur(8px);
    }}
    .traderq-brand {{ font-weight:800; letter-spacing:.02em; font-size: 1.1rem; }}
    .traderq-pill {{
      border:1px solid var(--border); border-radius:999px; padding:6px 10px;
      background: rgba(255,255,255,.05); font-weight:600;
    }}
    /* Cards */
    .pro-card {{
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
      border-radius: 14px; padding: 14px 16px; box-shadow: var(--glow);
    }}
    .chip {{ display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(255,255,255,0.05); font-weight:600; }}
    .chip .dot {{ width:8px; height:8px; border-radius:50%; display:inline-block; }}
    .chip.bull .dot {{ background: var(--good); }}
    .chip.bear .dot {{ background: var(--bad); }}
    .chip.flat .dot {{ background: var(--muted); }}

    /* tighten layout */
    section.main > div {{ padding-top: 0.5rem; }}
    </style>
    ''',
    unsafe_allow_html=True
)

# Header bar (shows version)
st.markdown(
    f'''
st.markdown(
    f'''
    <div class="traderq-nav">
      <div class="traderq-brand">âš¡ TraderQ â€” SMA 20/200</div>
      <div class="traderq-pill">Version: <b>{APP_VERSION}</b></div>
    </div>
    ''',
    unsafe_allow_html=True
)
      <div class="traderq-pill">Version: <b>{APP_VERSION}</b></div>
    </div>
    ''',
    unsafe_allow_html=True
)

def render_trend_chip(state: str) -> str:
    s = (state or "").lower()
    if any(x in s for x in ["golden","bull","up"]):
        klass, label = "bull", "Bullish"
    elif any(x in s for x in ["death","bear","down"]):
        klass, label = "bear", "Bearish"
    else:
        klass, label = "flat", "Sideways"
    return f'<span class="chip {klass}"><span class="dot"></span>{label}</span>'
# === PRO_CSS_v170_END ===
# === UI PRO BLOCK v1.6.0 START ===
import plotly.io as pio

# Replace deprecated experimental query params with new API
try:
    _qp = st.query_params
except Exception:
    # Fallback to dict-like if older Streamlit (shouldn't happen on 1.39)
    _qp = {}

def _get_qp_bool(name: str, default: bool = False) -> bool:
    v = st.query_params.get(name)
    if v is None: 
        return default
    if isinstance(v, (list, tuple)) and v:
        v = v[0]
    return str(v).lower() in {"1","true","yes","on"}

def _set_qp(**kwargs):
    # Persist selections to URL
    for k,v in kwargs.items():
        st.query_params[k] = str(v)

# --- Theme toggle (persists in URL) ---
if "dark_mode" not in st.session_state:
    st.session_state.dark_mode = _get_qp_bool("dark", False)

with st.sidebar:
    st.markdown("### Appearance")
    dark = st.toggle("Dark mode", value=st.session_state.dark_mode, key="dark_mode")
    _set_qp(dark=dark)

# Set default plotly template globally (propagates to all figures)
pio.templates.default = "plotly_dark" if st.session_state.dark_mode else "plotly_white"

# --- Global CSS for a high-tech, professional look ---
st.markdown(
    '''
    <style>
    :root {
      --bg: #0b1020;
      --card: #11162a;
      --text: #e8ecf3;
      --muted: #a6b0c3;
      --accent: #6ae3ff;
      --accent2: #7af59a;
      --warn: #ffb86b;
      --bad: #ff6b6b;
      --good: #26d07c;
      --border: #20263d;
    }
    .stApp {
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, Roboto, "Helvetica Neue", Arial, sans-serif;
      letter-spacing: .01em;
    }
    /* Auto light/dark */
    body {
      background: %(bg)s;
      color: %(text)s;
    }
    /* Cards (metrics, containers) */
    .metric-card, .stContainer {
      border: 1px solid %(border)s !important;
      background: %(card)s !important;
      border-radius: 14px !important;
      padding: 12px 14px !important;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.02), 0 8px 24px rgba(0,0,0,0.35);
    }
    /* Headers */
    h1,h2,h3 { letter-spacing: .02em; }
    h1 { font-weight: 700; }
    /* Buttons */
    .stButton>button {
      border-radius: 10px; border: 1px solid %(border)s;
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: %(text)s;
    }
    .stButton>button:hover { border-color: %(accent)s; box-shadow: 0 0 0 1px %(accent)s inset; }
    /* Chips */
    .chip {
      display:inline-flex; align-items:center; gap:8px; padding:4px 10px; border-radius:999px;
      border:1px solid %(border)s; background:rgba(255,255,255,0.04); font-weight:600;
    }
    .chip .dot { width:8px; height:8px; border-radius:50%%; display:inline-block; }
    .chip.bull .dot { background:%(good)s; }
    .chip.bear .dot { background:%(bad)s; }
    .chip.flat .dot { background:%(muted)s; }
    /* Dataframe tweaks */
    .stDataFrame { border-radius: 12px; overflow:hidden; }
    .stDataFrame [data-testid="stTable"] { background: transparent; }
    </style>
    ''' % ({
        "bg": "#0b1020" if st.session_state.dark_mode else "white",
        "card": "#11162a" if st.session_state.dark_mode else "white",
        "text": "#e8ecf3" if st.session_state.dark_mode else "#111827",
        "muted": "#a6b0c3" if st.session_state.dark_mode else "#6b7280",
        "accent": "#6ae3ff",
        "accent2": "#7af59a",
        "warn": "#ffb86b",
        "bad": "#ff6b6b",
        "good": "#26d07c",
        "border": "#20263d" if st.session_state.dark_mode else "#e5e7eb",
    }),
    unsafe_allow_html=True,
)

def chip_trend(state: str) -> str:
    state = (state or "").lower()
    if "bull" in state or "up" in state or "golden" in state:
        klass = "bull"; label = "Bullish"
    elif "bear" in state or "down" in state or "death" in state:
        klass = "bear"; label = "Bearish"
    else:
        klass = "flat"; label = "Sideways"
    return f'<span class="chip {klass}"><span class="dot"></span>{label}</span>'

# === UI PRO BLOCK v1.6.0 END ===

APP_VERSION = "v1.7.0"

# --- Settings / Defaults ---
DEFAULT_STOCKS = ["^GSPC", "^DJI", "^IXIC", "SPY", "QQQ"]
DEFAULT_CRYPTOS = ["BTC-USD", "ETH-USD", "SOL-USD"]
DEFAULT_PERIOD_DAYS = 365 * 2  # 2 years for stocks; crypto API may cap to 365 in fallback
SMA_SHORT = 20
SMA_LONG = 200

# --- Lazy imports for data providers ---
@lru_cache(maxsize=1)
def _yf():
    import yfinance as yf
    return yf

@lru_cache(maxsize=1)
def _cg():
    from pycoingecko import CoinGeckoAPI
    return CoinGeckoAPI()

# --- Utilities ---
def _ensure_datetime_index(df: pd.DataFrame) -> pd.DataFrame:
    if not isinstance(df.index, pd.DatetimeIndex):
        df.index = pd.to_datetime(df.index, utc=False)
    df = df.sort_index()
    return df

def _to_ohlc(df: pd.DataFrame) -> pd.DataFrame:
    """
    Normalize to ['open','high','low','close','volume'].
    Robust to yfinance MultiIndex columns like ('Open','SPY') or ('SPY','Open').
    """
    import numpy as _np
    import pandas as _pd

    if df is None or len(df) == 0:
        return _pd.DataFrame(columns=["open","high","low","close","volume"])

    # Flatten MultiIndex columns by picking the OHLC token where present
    if isinstance(df.columns, _pd.MultiIndex):
        flat_cols = []
        for col in df.columns:
            parts = [str(p) for p in col if p is not None]
            tokens = [p.lower() for p in parts]
            field = None
            for p in tokens:
                if p in {"open","high","low","close","adj close","adj_close","adjclose","volume"}:
                    field = p
                    break
            if field is None:
                field = tokens[-1] if tokens else "close"
            if field == "adj close":
                field = "adj_close"
            flat_cols.append(field)
        df.columns = flat_cols
    else:
        df.columns = [str(c) for c in df.columns]

    cols_lower = [c.lower() for c in df.columns]
    out = _pd.DataFrame(index=df.index)

    def pick(*cands):
        for name in cands:
            name_l = name.lower()
            if name_l in cols_lower:
                return df.iloc[:, cols_lower.index(name_l)]
        return _pd.Series(_np.nan, index=df.index, dtype="float64")

    out["open"]   = pick("open")
    out["high"]   = pick("high")
    out["low"]    = pick("low")
    close_series  = pick("close")
    if close_series.isna().all():
        close_series = pick("adj_close","adj close","adjclose")
    out["close"]  = close_series
    out["volume"] = pick("volume")

    return out

def _sma(series: pd.Series, window: int) -> pd.Series:
    return series.rolling(window=window, min_periods=1).mean()

def _pct(a: float, b: float) -> float:
    if b == 0 or (b is None) or (a is None) or np.isnan(a) or np.isnan(b):
        return np.nan
    return (a / b - 1.0) * 100.0

def _badge_color(trend: str) -> str:
    if trend == "Bullish":
        return "background-color:#12391a;color:#1fd16c;font-weight:600"
    if trend == "Bearish":
        return "background-color:#3a1919;color:#ff4d4f;font-weight:600"
    return ""

# --- Data loaders ---
@st.cache_data(show_spinner=False)
def load_stock(ticker: str, start: date, end: date) -> pd.DataFrame:
    yf = _yf()
    df = yf.download(
        tickers=ticker,
        start=start.isoformat(),
        end=(end + timedelta(days=1)).isoformat(),
        auto_adjust=True,
        progress=False,
        group_by="column",
        threads=True,
    )
    if df is None or len(df) == 0:
        return pd.DataFrame()
    df = _ensure_datetime_index(df)
    df = _to_ohlc(df)
    return df

def _cg_id_for(symbol_usd: str) -> str | None:
    # crude mapping for popular coins
    symbol = symbol_usd.upper().replace("-USD", "")
    mapping = {
        "BTC": "bitcoin",
        "ETH": "ethereum",
        "SOL": "solana",
        "ADA": "cardano",
        "XRP": "ripple",
        "DOGE": "dogecoin",
    }
    return mapping.get(symbol)

@st.cache_data(show_spinner=False)
def load_crypto(ticker: str, start: date, end: date) -> pd.DataFrame:
    """Try Yahoo Finance first for -USD pairs; fallback to CoinGecko (capped to 365d)."""
    # Try yfinance for e.g. 'BTC-USD'
    try:
        df_y = load_stock(ticker, start, end)
        if len(df_y) > 0 and not df_y["close"].isna().all():
            return df_y
    except Exception:
        pass

    # CoinGecko fallback (range limited to 365 days on public plan)
    try:
        cg = _cg()
        cg_id = _cg_id_for(ticker)
        if not cg_id:
            return pd.DataFrame()

        # Respect 365d cap
        max_days = 365
        s_cap = max(end - timedelta(days=max_days), start)
        from_ts = int(datetime.combine(s_cap, datetime.min.time()).timestamp())
        to_ts = int(datetime.combine(end, datetime.min.time()).timestamp())

        payload = cg.get_coin_market_chart_range_by_id(
            id=cg_id,
            vs_currency="usd",
            from_timestamp=from_ts,
            to_timestamp=to_ts,
        )
        if not payload or "prices" not in payload:
            return pd.DataFrame()

        # Build OHLC from prices (minute/daily granularity → we’ll downsample to 1D)
        prices = payload.get("prices", [])
        df = pd.DataFrame(prices, columns=["ts", "price"])
        df["ts"] = pd.to_datetime(df["ts"], unit="ms")
        # 1D resample for OHLC
        ohlc = df.set_index("ts")["price"].resample("1D").agg(["first", "max", "min", "last"])
        ohlc.columns = ["open", "high", "low", "close"]
        ohlc["volume"] = np.nan
        ohlc = ohlc.loc[(ohlc.index.date >= start) & (ohlc.index.date <= end)]
        return ohlc
    except Exception:
        return pd.DataFrame()

@st.cache_data(show_spinner=False)
def load_data(ticker: str, start: date, end: date, mode: str) -> pd.DataFrame:
    if mode == "Stocks":
        return load_stock(ticker, start, end)
    return load_crypto(ticker, start, end)

# --- Chart builder ---
def make_chart(df: pd.DataFrame, title: str, theme: str, pretouch_pct: float | None) -> go.Figure:
    if df.empty:
        fig = go.Figure()
        fig.update_layout(template="plotly_dark" if theme == "Dark" else "plotly_white", title=title)
        return fig

    df = df.copy()
    df["SMA20"] = _sma(df["close"], SMA_SHORT)
    df["SMA200"] = _sma(df["close"], SMA_LONG)

    template = "plotly_dark" if theme == "Dark" else "plotly_white"
    fig = go.Figure()
    fig.add_trace(go.Candlestick(
        x=df.index,
        open=df["open"], high=df["high"], low=df["low"], close=df["close"],
        name="Price"
    ))
    fig.add_trace(go.Scatter(x=df.index, y=df["SMA20"], mode="lines", name=f"SMA {SMA_SHORT}", line=dict(width=2)))
    fig.add_trace(go.Scatter(x=df.index, y=df["SMA200"], mode="lines", name=f"SMA {SMA_LONG}", line=dict(width=2)))

    # Cross markers (golden/death)
    cross_up = (df["SMA20"].shift(1) < df["SMA200"].shift(1)) & (df["SMA20"] >= df["SMA200"])
    cross_dn = (df["SMA20"].shift(1) > df["SMA200"].shift(1)) & (df["SMA20"] <= df["SMA200"])

    for idx in df.index[cross_up.fillna(False)]:
        fig.add_vline(x=idx, line_width=1, line_dash="dash", line_color="rgba(0,180,0,0.45)")
    for idx in df.index[cross_dn.fillna(False)]:
        fig.add_vline(x=idx, line_width=1, line_dash="dash", line_color="rgba(200,0,0,0.45)")

    # Pretouch band (symmetric % around SMA200)
    if pretouch_pct and pretouch_pct > 0:
        band = df["SMA200"] * (pretouch_pct / 100.0)
        upper = df["SMA200"] + band
        lower = df["SMA200"] - band
        fig.add_trace(go.Scatter(
            x=df.index, y=upper, line=dict(width=0), showlegend=False, hoverinfo="skip"
        ))
        fig.add_trace(go.Scatter(
            x=df.index, y=lower, fill="tonexty", name=f"Pretouch ±{pretouch_pct:.2f}%",
            hoverinfo="skip", opacity=0.15
        ))

    fig.update_layout(
        template=template,
        title=title,
        xaxis_rangeslider_visible=False,
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0),
        margin=dict(l=10, r=10, t=40, b=10),
        height=520
    )
    return fig

# --- Screener helper ---
def build_screener(tickers: list[str], start: date, end: date, mode: str, pretouch_pct: float | None) -> pd.DataFrame:
    rows = []
    for t in tickers:
        d = load_data(t, start, end, mode)
        if d.empty or d["close"].isna().all():
            continue
        d = d.copy()
        d["SMA20"] = _sma(d["close"], SMA_SHORT)
        d["SMA200"] = _sma(d["close"], SMA_LONG)
        last = d.iloc[-1]

        price = float(last["close"])
        sma20 = float(last["SMA20"])
        sma200 = float(last["SMA200"])

        trend = ("Bullish" if (not math.isnan(sma20) and not math.isnan(sma200) and sma20 > sma200)
                 else ("Bearish" if (not math.isnan(sma20) and not math.isnan(sma200)) else "-"))

        row = {
            "Ticker": t,
            "Trend": trend,
            "Last": price,
            "SMA20": sma20,
            "SMA200": sma200,
            "Dist to SMA200 (%)": _pct(price, sma200),
            "Dist to SMA20 (%)": _pct(price, sma20),
        }
        # Optional: whether price is inside pretouch band
        if pretouch_pct and pretouch_pct > 0 and not math.isnan(sma200):
            band = sma200 * (pretouch_pct / 100.0)
            row["In Pretouch Band"] = (sma200 - band) <= price <= (sma200 + band)
        rows.append(row)

    df = pd.DataFrame(rows)
    if df.empty:
        return df
    df = df.sort_values(by=["Dist to SMA200 (%)"], key=lambda s: s.abs()).reset_index(drop=True)
    return df

# --- UI ---

st.title(f"TraderQ SMA 20/200 Tracker — {APP_VERSION}")

# Sidebar controls
mode = st.sidebar.radio("Market", ["Stocks", "Crypto"], horizontal=True)
theme = st.sidebar.radio("Chart Theme", ["Dark", "Light"], index=0, horizontal=True)
pretouch = st.sidebar.slider("Pretouch band around SMA200 (%)", min_value=0.0, max_value=5.0, value=1.0, step=0.25)
period_days = st.sidebar.select_slider("Lookback (days)", options=[180, 365, 540, 730], value=365)

# Date range
end_d = date.today()
start_d = end_d - timedelta(days=int(period_days))

# Ticker selection
universe = DEFAULT_STOCKS if mode == "Stocks" else DEFAULT_CRYPTOS
left, right = st.columns([1, 3])
with left:
    st.subheader("Symbols")
    selected = st.multiselect("Choose tickers", options=universe, default=universe, key=f"choose_{mode}")
with right:
    st.subheader("Quick Add")
    custom = st.text_input("Add ticker (Yahoo symbol)", value="", placeholder="e.g., AAPL or BTC-USD")
    if custom.strip():
        if custom.strip() not in selected:
            selected.append(custom.strip())

# Safety: unique list
selected = list(dict.fromkeys(selected))

# --- Per-ticker charts ---
for t in selected:
    df = load_data(t, start_d, end_d, mode)
    cols = st.columns([3, 1], gap="large")
    with cols[0]:
        st.markdown(f"**{t}**")
        fig = make_chart(df, f"{t} — SMA {SMA_SHORT}/{SMA_LONG}", theme, pretouch)
        st.plotly_chart(fig, use_container_width=True, key=f"chart_{t}_{mode}")
    with cols[1]:
        if df.empty:
            st.info("No data.")
        else:
            d = df.copy()
            d["SMA20"] = _sma(d["close"], SMA_SHORT)
            d["SMA200"] = _sma(d["close"], SMA_LONG)
            last = d.iloc[-1]
            price = float(last["close"])
            sma20 = float(last["SMA20"])
            sma200 = float(last["SMA200"])
            st.metric("Last Close", f"${price:,.2f}")
            st.metric(f"SMA {SMA_SHORT}", f"${sma20:,.2f}")
            st.metric(f"SMA {SMA_LONG}", f"${sma200:,.2f}")
            st.metric("20 vs 200", f"{_pct(sma20, sma200):+.2f}%")

# --- Screener ---
st.divider()
st.subheader("Pretouch Screener (closest to SMA200 on top)")

screener_df = build_screener(selected or universe, start_d, end_d, mode, pretouch)
if screener_df.empty:
    st.info("No data to screen.")
else:
    show_cols = ["Ticker", "Trend", "Last", "SMA20", "SMA200", "Dist to SMA200 (%)", "Dist to SMA20 (%)"]
    s = screener_df[show_cols].style.apply(
        lambda col: [_badge_color(v) for v in col], subset=["Trend"]
    ).format({
        "Last": "${:,.2f}",
        "SMA20": "${:,.2f}",
        "SMA200": "${:,.2f}",
        "Dist to SMA200 (%)": "{:+.2f}%",
        "Dist to SMA20 (%)": "{:+.2f}%"
    })
    st.dataframe(s, use_container_width=True, hide_index=True)
    st.download_button(
        label="Download Screener CSV",
        data=screener_df.to_csv(index=False).encode("utf-8"),
        file_name="pretouch_screener.csv",
        mime="text/csv",
        key="dl_screener_csv"
    )

# --- Footnote / Diagnostics ---
with st.expander("About / Diagnostics"):
    st.write("If crypto history appears short, CoinGecko free API caps range to ~365 days. "
             "The app falls back between Yahoo and CoinGecko automatically.")
    st.write("Built with Streamlit, yfinance, CoinGecko, Plotly. No paid data sources.")


# ===== HOTFIX (_to_ohlc override) v1.4.3 =====
def _to_ohlc(df: pd.DataFrame) -> pd.DataFrame:
    """
    Normalize to columns: ['open','high','low','close','volume'].
    Robust to yfinance MultiIndex like ('Open','SPY') or ('SPY','Open').
    """
    import numpy as _np
    import pandas as _pd

    if df is None or len(df) == 0:
        return _pd.DataFrame(columns=["open","high","low","close","volume"])

    # Flatten MultiIndex columns by choosing the OHLC token if present.
    if isinstance(df.columns, _pd.MultiIndex):
        flat_cols = []
        for col in df.columns:
            parts = [str(p) for p in col if p is not None]
            tokens = [p.lower() for p in parts]
            field = None
            for p in tokens:
                if p in {"open","high","low","close","adj close","adj_close","adjclose","volume"}:
                    field = p
                    break
            if field is None:
                field = tokens[-1] if tokens else "close"
            if field == "adj close":
                field = "adj_close"
            flat_cols.append(field)
        df.columns = flat_cols
    else:
        df.columns = [str(c) for c in df.columns]

    cols_lower = [c.lower() for c in df.columns]
    out = _pd.DataFrame(index=df.index)

    def pick(*cands):
        for name in cands:
            name_l = name.lower()
            if name_l in cols_lower:
                return df.iloc[:, cols_lower.index(name_l)]
        return _pd.Series(_np.nan, index=df.index, dtype="float64")

    out["open"]   = pick("open")
    out["high"]   = pick("high")
    out["low"]    = pick("low")
    close_series  = pick("close")
    if close_series.isna().all():
        close_series = pick("adj_close","adj close","adjclose")
    out["close"]  = close_series
    out["volume"] = pick("volume")
    return out
# ===== END HOTFIX =====







