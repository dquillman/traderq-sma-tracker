import streamlit as st
import pandas as pd
import numpy as np
import datetime as dt
import time
import plotly.graph_objects as go
import pandas_datareader.data as pdr
from pycoingecko import CoinGeckoAPI

# =========================
# Page / UX
# =========================
st.set_page_config(
    page_title="SMA Pro",
    layout="wide",
    menu_items={
        "Get help": "https://github.com/dquillman/traderq-sma-tracker",
        "Report a bug": "https://github.com/dquillman/traderq-sma-tracker/issues",
    },
)

# Theme toggle
theme = st.sidebar.radio("Theme", ["Dark", "Light"], horizontal=True)
if theme == "Dark":
    st.markdown("""
    <style>
      .stMetric { background: #121417; border-radius: 12px; padding: 8px; }
      .stDataFrame { filter: brightness(0.97); }
    </style>
    """, unsafe_allow_html=True)
else:
    st.markdown("""
    <style>
      .stMetric { background: #f7f7f9; border-radius: 12px; padding: 8px; }
    </style>
    """, unsafe_allow_html=True)

st.title("üìà SMA 20/200 Stock & Crypto Tracker (Pro)")

# =========================
# Helpers
# =========================
INDEX_TO_ETF = {"^GSPC": "SPY", "^DJI": "DIA", "^IXIC": "QQQ"}
CG_IDS = {"BTC": "bitcoin", "ETH": "ethereum", "SOL": "solana", "DOGE": "dogecoin"}

def fmt(value, kind="usd"):
    if value is None or (isinstance(value, float) and np.isnan(value)):
        return "-"
    if kind == "usd":
        return f"${value:,.2f}"
    elif kind == "pct":
        return f"{value:+.2f}%"
    else:
        return f"{value:,.2f}"

def _compute_indicators(df: pd.DataFrame) -> pd.DataFrame:
    if df.empty:
        return df
    df = df.rename(columns={"Open":"open","High":"high","Low":"low","Close":"close","Volume":"volume"})
    df.index = pd.to_datetime(df.index)
    df["SMA20"]  = df["close"].rolling(20,  min_periods=20).mean()
    df["SMA200"] = df["close"].rolling(200, min_periods=200).mean()
    df["signal"] = np.where(
        (df["SMA20"].notna())&(df["SMA200"].notna())&(df["SMA20"]>df["SMA200"]), 1,
        np.where((df["SMA20"].notna())&(df["SMA200"].notna())&(df["SMA20"]<df["SMA200"]), -1, 0)
    )
    df["xover"] = df["signal"].diff().fillna(0)  # +2 golden, -2 death
    return df

# -------------------------
# Data sources (no paid APIs)
# -------------------------
def _load_equity_stooq(ticker: str, start: dt.date, end: dt.date) -> pd.DataFrame:
    t = INDEX_TO_ETF.get(ticker, ticker)  # map ^GSPC‚ÜíSPY, etc.
    try:
        df = pdr.DataReader(t, "stooq", start, end)  # newest‚Üíoldest
        df = df.sort_index()
    except Exception:
        df = pd.DataFrame()
    return _compute_indicators(df)

def _load_crypto_coingecko(ticker: str, start: dt.date, end: dt.date) -> pd.DataFrame:
    # Expect BTC-USD, ETH-USD, ...
    if not ticker.upper().endswith("-USD"):
        return pd.DataFrame()
    symbol = ticker.split("-")[0].upper()
    cg_id = CG_IDS.get(symbol)
    if not cg_id:
        return pd.DataFrame()

    total_days = max(1, (end - start).days)
    # Free tier: clamp to last 365 days via "market_chart"
    if total_days > 365:
        if "cg_clamp_notified" not in st.session_state:
            st.info("‚ö†Ô∏è CoinGecko free API limited to 365 days ‚Äî showing the most recent year of data.")
            st.session_state["cg_clamp_notified"] = True
        days = 365
    else:
        days = total_days

    cg = CoinGeckoAPI()
    try:
        data = cg.get_coin_market_chart_by_id(id=cg_id, vs_currency="usd", days=days)
        prices = data.get("prices", [])
    except Exception:
        prices = []

    if not prices:
        return pd.DataFrame()

    s = pd.Series({pd.to_datetime(p[0], unit="ms").normalize(): p[1] for p in prices})
    s = s.groupby(s.index).last()

    df = s.to_frame("close")
    df["open"] = df["close"]; df["high"] = df["close"]; df["low"] = df["close"]
    df["volume"] = 0.0
    df.index = pd.to_datetime(df.index)
    df = df.loc[(df.index.date >= start) & (df.index.date <= end)]
    return _compute_indicators(df)

@st.cache_data(ttl=3600)
def load_data(ticker: str, start: dt.date, end: dt.date) -> pd.DataFrame:
    if ticker.upper().endswith("-USD"):
        return _load_crypto_coingecko(ticker, start, end)
    return _load_equity_stooq(ticker, start, end)

# -------------------------
# Analytics / Screener / Backtest
# -------------------------
def signal_table(df: pd.DataFrame) -> pd.DataFrame:
    out = []
    sigs = df[df["xover"].isin([2, -2])]
    for idx, row in sigs.iterrows():
        out.append({
            "Date": idx.date(),
            "Type": "Golden Cross" if row["xover"] == 2 else "Death Cross",
            "Close": round(float(row["close"]), 2) if not np.isnan(row["close"]) else None,
            "SMA20": round(float(row["SMA20"]), 2) if not np.isnan(row["SMA20"]) else None,
            "SMA200": round(float(row["SMA200"]), 2) if not np.isnan(row["SMA200"]) else None,
        })
    return pd.DataFrame(out)

def distance_to_sma(df: pd.DataFrame, which="SMA200"):
    if df.empty or which not in df: return np.nan
    c = df["close"].iloc[-1]
    s = df[which].iloc[-1]
    return (c/s - 1)*100 if s else np.nan

def backtest_sma(df: pd.DataFrame, fee_bp: float = 1.0):
    d = df.dropna(subset=["SMA20","SMA200","close"]).copy()
    if d.empty:
        return {"CAGR (Strategy)": np.nan, "CAGR (Buy&Hold)": np.nan, "Max Drawdown": np.nan, "Sharpe": np.nan, "Trades": 0}, pd.DataFrame()
    d["pos"] = (d["SMA20"] > d["SMA200"]).astype(int)
    d["ret"] = d["close"].pct_change().fillna(0)
    d["strat_ret"] = d["pos"].shift(1).fillna(0) * d["ret"]
    trades = (d["pos"].diff().abs() > 0).astype(int)
    d["strat_ret"] -= trades * (fee_bp/10000.0)
    d["eq"] = (1 + d["strat_ret"]).cumprod()
    d["bh"] = (1 + d["ret"]).cumprod()

    n_years = max(1e-9, (d.index[-1]-d.index[0]).days/365.25)
    cagr     = d["eq"].iloc[-1]**(1/n_years) - 1
    cagr_bh  = d["bh"].iloc[-1]**(1/n_years) - 1
    dd       = (d["eq"]/d["eq"].cummax()-1).min()
    vol      = d["strat_ret"].std()*np.sqrt(252)
    sharpe   = (d["strat_ret"].mean()*252) / (vol + 1e-12)

    return {
        "CAGR (Strategy)": cagr, "CAGR (Buy&Hold)": cagr_bh,
        "Max Drawdown": dd, "Sharpe": sharpe, "Trades": int(trades.sum())
    }, d[["eq","bh"]]

# -------------------------
# Charting
# -------------------------
def add_verticals(fig, df):
    for idx, row in df[df["xover"].isin([2,-2])].iterrows():
        fig.add_vline(x=idx, line_width=1, line_dash="dash", line_color="rgba(255,255,255,0.3)")

def plot_chart(df: pd.DataFrame, ticker: str, pretouch_pct: float = 0):
    fig = go.Figure()

    # Pretouch bands (around SMA200)
    if pretouch_pct and pretouch_pct > 0:
        upper_band = df["SMA200"] * (1 + pretouch_pct/100)
        lower_band = df["SMA200"] * (1 - pretouch_pct/100)
        fig.add_trace(go.Scatter(x=df.index, y=upper_band, line=dict(color="gray", width=1, dash="dot"),
                                 name=f"SMA200 +{pretouch_pct}%"))
        fig.add_trace(go.Scatter(x=df.index, y=lower_band, line=dict(color="gray", width=1, dash="dot"),
                                 name=f"SMA200 -{pretouch_pct}%"))

    # Price
    fig.add_trace(go.Candlestick(
        x=df.index, open=df["open"], high=df["high"], low=df["low"], close=df["close"], name="Price"
    ))

    # SMAs
    fig.add_trace(go.Scatter(x=df.index, y=df["SMA20"],  name="SMA 20",  line=dict(color="orange", width=2)))
    fig.add_trace(go.Scatter(x=df.index, y=df["SMA200"], name="SMA 200", line=dict(color="blue",   width=2)))

    # Cross markers
    golden = df[df["xover"] == 2]
    death  = df[df["xover"] == -2]
    fig.add_trace(go.Scatter(
        x=golden.index, y=golden["close"], mode="markers+text",
        name="Golden Cross", text=["üü¢"]*len(golden), textposition="top center",
        marker=dict(size=16, color="lime", symbol="triangle-up", line=dict(width=1, color="black")),
        hovertext=["Golden Cross"]*len(golden), hoverinfo="text+y"
    ))
    fig.add_trace(go.Scatter(
        x=death.index, y=death["close"], mode="markers+text",
        name="Death Cross", text=["üî¥"]*len(death), textposition="bottom center",
        marker=dict(size=16, color="red", symbol="triangle-down", line=dict(width=1, color="black")),
        hovertext=["Death Cross"]*len(death), hoverinfo="text+y"
    ))
    add_verticals(fig, df)

    # Layout
    if theme == "Dark":
        plot_bg="#0e1117"; paper_bg="#0e1117"; text_c="#e8e6e3"
    else:
        plot_bg="#ffffff"; paper_bg="#ffffff"; text_c="#111827"

    fig.update_layout(
        title=f"{ticker} ‚Äì SMA 20/200 with Pretouch & Crosses",
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        plot_bgcolor=plot_bg, paper_bgcolor=paper_bg, font=dict(color=text_c),
        xaxis_rangeslider_visible=False
    )

    # UNIQUE key per ticker to avoid duplicate-element error
    st.plotly_chart(fig, use_container_width=True, key=f"{ticker}_chart")

# =========================
# URL Params (shareable)
# =========================
qs = st.query_params  # new API

# =========================
# Sidebar Inputs
# =========================
mode = st.sidebar.radio("Market Type", ["Stocks / Indexes", "Crypto (USD Pairs)"])
if mode.startswith("Stocks"):
    default_tickers = ["^GSPC", "SPY", "^DJI", "DIA", "^IXIC", "QQQ"]
else:
    default_tickers = ["BTC-USD", "ETH-USD", "SOL-USD", "DOGE-USD"]

tickers_text_default = ", ".join(default_tickers)
if "tickers" in qs:
    tickers_text_default = qs.get("tickers", "")

tickers_text = st.sidebar.text_input("Tickers (comma separated)", tickers_text_default)
tickers = [t.strip() for t in tickers_text.split(",") if t.strip()]
# write back to URL params
st.query_params["tickers"] = ",".join(tickers)

start = st.sidebar.date_input("Start Date", dt.date.today() - dt.timedelta(days=365))
end   = st.sidebar.date_input("End Date",   dt.date.today())
pretouch_pct = st.sidebar.slider("Pretouch Band (%)", 0.0, 10.0, 2.0, 0.5)

show_screener = st.sidebar.checkbox("Show Pretouch Screener", value=True)

# =========================
# Screener (optional)
# =========================
if show_screener and len(tickers) > 0:
    rows = []
    for t in tickers:
        d = load_data(t, start, end)
        rows.append({
            "Ticker": t,
            "Dist to SMA200 (%)": round(distance_to_sma(d,"SMA200"), 2),
            "Dist to SMA20 (%)":  round(distance_to_sma(d,"SMA20"),  2)
        })
        # polite rate-limiting for CoinGecko
        if t.upper().endswith("-USD"):
            time.sleep(0.5)
    screener_df = pd.DataFrame(rows).sort_values("Dist to SMA200 (%)", key=lambda s: s.abs())
    st.subheader("üîé Pretouch Screener (closest to SMA200 on top)")
    st.dataframe(screener_df, use_container_width=True, hide_index=True)

# =========================
# Main per-ticker view (Tabs)
# =========================
for tkr in tickers:
    st.markdown("---")
    st.subheader(tkr)

    df = load_data(tkr, start, end)
    if df.empty:
        st.warning(f"No data for {tkr}.")
        continue

    price = df["close"].iloc[-1]
    sma20 = df["SMA20"].iloc[-1]
    sma200 = df["SMA200"].iloc[-1]
    pct_diff = ((sma20 - sma200) / sma200 * 100) if (sma200 and not np.isnan(sma200)) else np.nan

    m1, m2, m3 = st.columns(3)
    m1.metric("Last Close", fmt(price, "usd"))
    m2.metric("SMA 20",     fmt(sma20, "usd"))
    m3.metric("20 vs 200",  fmt(pct_diff, "pct"))

    tab_chart, tab_signals, tab_stats = st.tabs(["üìà Chart", "‚ö° Signals", "üìä Stats"])

    with tab_chart:
        plot_chart(df, tkr, pretouch_pct)
        # Download CSV
        csv = df.to_csv().encode("utf-8")
        st.download_button("‚¨áÔ∏è Download CSV", data=csv, file_name=f"{tkr}.csv", mime="text/csv", key=f"{tkr}_csv")

    with tab_signals:
        st.dataframe(signal_table(df), use_container_width=True, hide_index=True)

    with tab_stats:
        metrics, curve = backtest_sma(df, fee_bp=1.0)
        c1, c2, c3, c4, c5 = st.columns(5)
        c1.metric("CAGR (Strat)", fmt(metrics["CAGR (Strategy)"]*100, "pct"))
        c2.metric("CAGR (B&H)",   fmt(metrics["CAGR (Buy&Hold)"]*100, "pct"))
        c3.metric("Max Drawdown", fmt(metrics["Max Drawdown"]*100, "pct"))
        c4.metric("Sharpe",       f'{metrics["Sharpe"]:.2f}' if not np.isnan(metrics["Sharpe"]) else "-")
        c5.metric("Trades",       str(metrics["Trades"]))
        if not curve.empty:
            curve_fig = go.Figure()
            curve_fig.add_trace(go.Scatter(x=curve.index, y=curve["eq"], name="Strategy Equity"))
            curve_fig.add_trace(go.Scatter(x=curve.index, y=curve["bh"], name="Buy & Hold", line=dict(dash="dot")))
            if theme == "Dark":
                curve_fig.update_layout(plot_bgcolor="#0e1117", paper_bgcolor="#0e1117", font=dict(color="#e8e6e3"))
            # UNIQUE key per ticker to avoid duplicate-element error
            st.plotly_chart(curve_fig, use_container_width=True, key=f"{tkr}_curve")

st.caption("Educational use only. Not financial advice. Data: Stooq & CoinGecko (free tiers).")
