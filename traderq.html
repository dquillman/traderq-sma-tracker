<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TraderQ SMA 20/200 Tracker - v2.5.0</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e8ecf3;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: linear-gradient(180deg, #0a0e27 0%, #1a1f3a 100%);
            border-right: 1px solid #00d4ff;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar h3 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 1px solid #00d4ff;
            padding-bottom: 8px;
        }

        .sidebar section {
            margin-bottom: 25px;
        }

        .sidebar hr {
            border: none;
            border-top: 1px solid rgba(0, 212, 255, 0.3);
            margin: 20px 0;
        }

        .sidebar label {
            display: block;
            margin-bottom: 8px;
            color: #b0b0b0;
            font-size: 14px;
        }

        .sidebar input[type="text"],
        .sidebar input[type="number"],
        .sidebar select {
            width: 100%;
            padding: 8px;
            background-color: #1a1f3a;
            border: 1px solid #00d4ff;
            border-radius: 6px;
            color: #ffffff;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .sidebar input[type="checkbox"] {
            margin-right: 8px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .sidebar input[type="radio"] {
            margin-right: 8px;
            margin-left: 10px;
            cursor: pointer;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .sidebar button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .sidebar button:hover {
            background: linear-gradient(90deg, #00ff88 0%, #00d4ff 100%);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
            transform: translateY(-2px);
        }

        .sidebar button:active {
            transform: translateY(0);
        }

        .sidebar input[type="range"] {
            width: 100%;
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #1a1f3a;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            transition: width 0.3s ease;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            padding: 20px 30px;
            border-bottom: 2px solid #00d4ff;
            background: rgba(0, 212, 255, 0.05);
        }

        .header h1 {
            color: #00d4ff;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .header .subtitle {
            color: #b0b0b0;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            background-color: #0a0e27;
            padding: 10px;
            gap: 8px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
            overflow-x: auto;
        }

        .tab {
            padding: 12px 24px;
            background-color: #1a1f3a;
            color: #b0b0b0;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .tab:hover {
            background-color: #2a2f4a;
        }

        .tab.active {
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .tab-content {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        .chart-container {
            width: 100%;
            height: 600px;
            margin-bottom: 30px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 153, 204, 0.1) 100%);
            border-left: 4px solid #00d4ff;
            border-radius: 6px;
            padding: 20px;
        }

        .metric-label {
            color: #b0b0b0;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .metric-value {
            color: #00d4ff;
            font-size: 24px;
            font-weight: 700;
        }

        .metric-delta {
            color: #00ff88;
            font-size: 12px;
            margin-top: 5px;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 153, 204, 0.1) 100%);
            border-left: 4px solid #00d4ff;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .success-box {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 212, 255, 0.1) 100%);
            border-left: 4px solid #00ff88;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .warning-box {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%);
            border-left: 4px solid #ffc107;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .error-box {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.1) 0%, rgba(211, 47, 47, 0.1) 100%);
            border-left: 4px solid #f44336;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #00d4ff;
        }

        .error {
            color: #f44336;
            padding: 20px;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 6px;
            margin-bottom: 20px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 300px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1f3a;
        }

        ::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ff88;
        }

        .ai-recommendation {
            background: rgba(0, 212, 255, 0.1);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .ai-recommendation h3 {
            color: #00d4ff;
            margin-bottom: 15px;
        }

        .signal-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            margin: 5px;
        }

        .signal-long {
            background: #00ff88;
            color: #000;
        }

        .signal-short {
            background: #f44336;
            color: #fff;
        }

        .signal-neutral {
            background: #b0b0b0;
            color: #000;
        }

        .server-startup {
            background: rgba(0, 212, 255, 0.1);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .server-startup h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00d4ff;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #00ff88;
            overflow-x: auto;
        }

        .download-btn {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(90deg, #00d4ff 0%, #0099cc 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            margin: 5px;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: linear-gradient(90deg, #00ff88 0%, #00d4ff 100%);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <h3>‚öôÔ∏è Configuration</h3>
        
        <section>
            <label>Market:</label>
            <div class="radio-group">
                <label><input type="radio" name="mode" value="Stocks" checked> Stocks</label>
                <label><input type="radio" name="mode" value="Crypto"> Crypto</label>
            </div>
        </section>

        <section>
            <label>Data Source:</label>
            <select id="dataSource">
                <option value="Yahoo Finance">Yahoo Finance</option>
                <option value="Alpha Vantage">Alpha Vantage (API Key Required)</option>
            </select>
            <input type="text" id="apiKey" placeholder="Alpha Vantage API Key (optional)" style="margin-top: 8px;">
            <div style="font-size: 11px; color: #888; margin-top: 8px; padding: 8px; background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; border-radius: 4px;">
                <strong>Note:</strong> Yahoo Finance uses CORS proxies. If loading fails, try Alpha Vantage API (free key at alphavantage.co) or install a CORS browser extension.
            </div>
        </section>

        <hr>

        <section>
            <h3>üìä Symbols</h3>
            <input type="text" id="tickerInput" placeholder="e.g., AAPL or BTC-USD" value="SPY">
            <button onclick="loadData()">Load Data</button>
        </section>

        <hr>

        <section>
            <h3>üìä Chart Settings</h3>
            <label>Chart Theme:</label>
            <div class="radio-group">
                <label><input type="radio" name="theme" value="Dark" checked> Dark</label>
                <label><input type="radio" name="theme" value="Light"> Light</label>
            </div>

            <label>Timeframe:</label>
            <select id="timeframe">
                <option value="1d">Daily</option>
                <option value="5m">5 Minutes</option>
                <option value="15m">15 Minutes</option>
                <option value="1h">1 Hour</option>
                <option value="1wk">Weekly</option>
                <option value="1mo">Monthly</option>
            </select>

            <label>Lookback (days):</label>
            <input type="number" id="periodDays" min="30" max="730" value="365">
        </section>

        <hr>

        <section>
            <h3>üìä Indicators</h3>
            <label><input type="checkbox" id="showSMA20" checked> Show SMA 20</label>
            <label><input type="checkbox" id="showSMA200" checked> Show SMA 200</label>
            <label><input type="checkbox" id="showEMA"> Show EMA</label>
            <label><input type="checkbox" id="showVolume"> Show Volume</label>
            <label><input type="checkbox" id="showRSI" checked> Show RSI</label>
            <label><input type="checkbox" id="showMACD" checked> Show MACD</label>
            <div id="macdModeContainer" style="margin-left: 20px; margin-top: 10px; display: none;">
                <label>MACD Mode:</label>
                <div class="radio-group">
                    <label><input type="radio" name="macdMode" value="Normal"> Normal</label>
                    <label><input type="radio" name="macdMode" value="Extended" checked> Extended</label>
                </div>
                <label>Lookback (bars):</label>
                <input type="number" id="macdSidewaysWindow" min="5" max="50" value="10">
                <label>Range Threshold (%):</label>
                <input type="number" id="macdSidewaysThreshold" min="1" max="20" step="0.5" value="8">
            </div>
            <label><input type="checkbox" id="showBollinger"> Show Bollinger Bands</label>
            <label><input type="checkbox" id="showSupertrend" checked> Show Supertrend</label>
            <label><input type="checkbox" id="showFVG" checked> Show Fair Value Gap</label>
        </section>

        <hr>

        <section>
            <h3>ü§ñ AI Recommendations</h3>
            <label><input type="checkbox" id="useSMA_AI" checked> Use SMA</label>
            <label><input type="checkbox" id="useRSI_AI" checked> Use RSI</label>
            <label><input type="checkbox" id="useMACD_AI" checked> Use MACD</label>
            <label><input type="checkbox" id="useSupertrend_AI" checked> Use Supertrend</label>
            <label><input type="checkbox" id="useFVG_AI" checked> Use FVG</label>
            <button onclick="generateAIRecommendation()">Generate AI Recommendation</button>
        </section>

        <hr>

        <div id="loadingStatus" style="display: none; color: #00d4ff; margin-top: 20px;">
            Loading data...
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="header">
            <h1>TraderQ SMA 20/200 Tracker</h1>
            <div class="subtitle">Professional Trading Analytics - v2.5.0</div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab(0)">üìà Tracker</button>
            <button class="tab" onclick="switchTab(1)">üîî Alerts</button>
            <button class="tab" onclick="switchTab(2)">üìä Cross History</button>
            <button class="tab" onclick="switchTab(3)">üíº Portfolio</button>
            <button class="tab" onclick="switchTab(4)">üß™ Backtesting</button>
            <button class="tab" onclick="switchTab(5)">üì∞ News</button>
            <button class="tab" onclick="switchTab(6)">üìê Patterns</button>
            <button class="tab" onclick="switchTab(7)">üîó Correlation</button>
            <button class="tab" onclick="switchTab(8)">üìù Journal</button>
            <button class="tab" onclick="switchTab(9)">‚ö° Signals</button>
            <button class="tab" onclick="switchTab(10)">üõ°Ô∏è Risk</button>
            <button class="tab" onclick="switchTab(11)">ü§ñ AI Recommendations</button>
        </div>

        <div class="tab-content" id="tabContent">
            <div id="trackerTab">
                <div class="chart-container" id="chart"></div>
                <div class="metrics" id="metrics"></div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentData = null;
        let currentTicker = 'SPY';
        let tradeParams = null; // {entry, stopLoss, target, direction}
        const APP_VERSION = 'v2.5.0';

        // Technical Indicators (JavaScript implementations)
        function sma(data, window) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                if (i < window - 1) {
                    result.push(NaN);
                } else {
                    let sum = 0;
                    for (let j = i - window + 1; j <= i; j++) {
                        sum += data[j];
                    }
                    result.push(sum / window);
                }
            }
            return result;
        }

        function ema(data, window) {
            const result = [];
            const multiplier = 2 / (window + 1);
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    result.push(data[i]);
                } else {
                    result.push((data[i] - result[i - 1]) * multiplier + result[i - 1]);
                }
            }
            return result;
        }

        function rsi(data, window = 14) {
            const result = [];
            const gains = [];
            const losses = [];

            for (let i = 1; i < data.length; i++) {
                const change = data[i] - data[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);
            }

            for (let i = 0; i < window; i++) {
                result.push(NaN);
            }

            let avgGain = gains.slice(0, window).reduce((a, b) => a + b, 0) / window;
            let avgLoss = losses.slice(0, window).reduce((a, b) => a + b, 0) / window;

            for (let i = window; i < gains.length; i++) {
                if (avgLoss === 0) {
                    result.push(100);
                } else {
                    const rs = avgGain / avgLoss;
                    result.push(100 - (100 / (1 + rs)));
                }

                avgGain = (avgGain * (window - 1) + gains[i]) / window;
                avgLoss = (avgLoss * (window - 1) + losses[i]) / window;
            }

            return result;
        }

        function macd(data, fast = 12, slow = 26, signal = 9) {
            const emaFast = ema(data, fast);
            const emaSlow = ema(data, slow);
            const macdLine = emaFast.map((val, i) => val - emaSlow[i]);
            const signalLine = ema(macdLine, signal);
            const histogram = macdLine.map((val, i) => val - signalLine[i]);
            return { macdLine, signalLine, histogram };
        }

        function sidewaysMask(data, window = 10, threshold = 0.08) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                if (i < window - 1) {
                    result.push(false);
                } else {
                    const slice = data.slice(i - window + 1, i + 1);
                    const max = Math.max(...slice);
                    const min = Math.min(...slice);
                    const mean = slice.reduce((a, b) => a + b, 0) / window;
                    const rangePct = (max - min) / mean;
                    result.push(rangePct < threshold);
                }
            }
            return result;
        }

        function macdExtended(data, fast = 12, slow = 26, signal = 9, sidewaysWindow = 10, sidewaysThreshold = 0.08) {
            const { macdLine, signalLine, histogram } = macd(data, fast, slow, signal);
            const mask = sidewaysMask(data, sidewaysWindow, sidewaysThreshold);
            
            const macdExt = macdLine.map((val, i) => mask[i] ? 0 : val);
            const signalExt = signalLine.map((val, i) => mask[i] ? 0 : val);
            const histExt = histogram.map((val, i) => mask[i] ? 0 : val);
            
            return { macdLine: macdExt, signalLine: signalExt, histogram: histExt };
        }

        function bollingerBands(data, window = 20, numStd = 2.0) {
            const smaValues = sma(data, window);
            const result = { upper: [], middle: smaValues, lower: [] };

            for (let i = 0; i < data.length; i++) {
                if (i < window - 1) {
                    result.upper.push(NaN);
                    result.lower.push(NaN);
                } else {
                    const slice = data.slice(i - window + 1, i + 1);
                    const mean = smaValues[i];
                    const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window;
                    const stdDev = Math.sqrt(variance);
                    result.upper.push(mean + (stdDev * numStd));
                    result.lower.push(mean - (stdDev * numStd));
                }
            }

            return result;
        }

        function atr(high, low, close, window = 14) {
            const trueRanges = [];
            for (let i = 1; i < close.length; i++) {
                const tr = Math.max(
                    high[i] - low[i],
                    Math.abs(high[i] - close[i - 1]),
                    Math.abs(low[i] - close[i - 1])
                );
                trueRanges.push(tr);
            }

            const result = new Array(close.length).fill(NaN);
            for (let i = window; i < close.length; i++) {
                const slice = trueRanges.slice(i - window, i);
                result[i] = slice.reduce((a, b) => a + b, 0) / window;
            }

            return result;
        }

        function supertrend(high, low, close, period = 10, multiplier = 3.0) {
            const atrValues = atr(high, low, close, period);
            const hlAvg = high.map((h, i) => (h + low[i]) / 2);
            
            const upperBand = hlAvg.map((hl, i) => hl + (multiplier * (atrValues[i] || 0)));
            const lowerBand = hlAvg.map((hl, i) => hl - (multiplier * (atrValues[i] || 0)));
            
            const supertrendValues = [];
            const trendValues = [];

            for (let i = 0; i < close.length; i++) {
                if (i === 0) {
                    supertrendValues.push(upperBand[i]);
                    trendValues.push(1);
                } else {
                    // Adjust upper band
                    if (close[i] <= upperBand[i - 1]) {
                        upperBand[i] = Math.min(upperBand[i], upperBand[i - 1]);
                    }
                    // Adjust lower band
                    if (close[i] >= lowerBand[i - 1]) {
                        lowerBand[i] = Math.max(lowerBand[i], lowerBand[i - 1]);
                    }
                    // Determine trend
                    if (close[i] <= supertrendValues[i - 1]) {
                        supertrendValues.push(upperBand[i]);
                        trendValues.push(-1);
                    } else {
                        supertrendValues.push(lowerBand[i]);
                        trendValues.push(1);
                    }
                }
            }

            return { supertrend: supertrendValues, trend: trendValues };
        }

        function findFairValueGaps(ohlc) {
            const fvgs = [];
            
            for (let i = 0; i < ohlc.length - 2; i++) {
                const c1 = ohlc[i];
                const c2 = ohlc[i + 1];
                const c3 = ohlc[i + 2];

                // Bullish FVG
                if (c2.low > c1.high && c3.low <= c1.high && c3.high >= c1.low) {
                    fvgs.push({
                        type: 'bullish',
                        start_date: c1.date,
                        end_date: c3.date,
                        gap_low: c1.high,
                        gap_high: c2.low
                    });
                }
                // Bearish FVG
                else if (c2.high < c1.low && c3.high >= c1.low && c3.low <= c1.high) {
                    fvgs.push({
                        type: 'bearish',
                        start_date: c1.date,
                        end_date: c3.date,
                        gap_low: c2.high,
                        gap_high: c1.low
                    });
                }
            }

            return fvgs;
        }

        function calculateATRStopLoss(high, low, close, atrMultiplier = 2.0, isLong = true) {
            if (high.length < 14 || low.length < 14 || close.length < 14) {
                return 0;
            }

            const atrValues = atr(high, low, close, 14);
            const currentATR = atrValues[atrValues.length - 1];
            const currentPrice = close[close.length - 1];

            if (isNaN(currentATR) || currentATR === 0) {
                return 0;
            }

            if (isLong) {
                return Math.max(0, currentPrice - (currentATR * atrMultiplier));
            } else {
                return currentPrice + (currentATR * atrMultiplier);
            }
        }

        // Data fetching with multiple CORS proxy fallbacks
        async function fetchYahooFinanceData(ticker, interval = '1d', period = 365) {
            // Check if running from file:// protocol
            if (window.location.protocol === 'file:') {
                throw new Error(`CORS Error: This file cannot load data when opened directly from file:// protocol.\n\nPlease:\n1. Use a local web server (e.g., Python: python -m http.server 8000)\n2. Or use Alpha Vantage API (requires free API key from alphavantage.co)\n3. Or install a CORS browser extension`);
            }
            
            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=${interval}&range=${period}d`;
            
            // Try multiple CORS proxy options
            const proxies = [
                // Option 1: allorigins with /get endpoint (returns JSON with contents field)
                { url: `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`, parser: (data) => {
                    if (data.contents) return JSON.parse(data.contents);
                    return data;
                }},
                // Option 2: corsproxy.io
                { url: `https://corsproxy.io/?${encodeURIComponent(url)}`, parser: (data) => data },
                // Option 3: thingproxy.freeboard.io
                { url: `https://thingproxy.freeboard.io/fetch/${url}`, parser: (data) => data },
                // Option 4: api.allorigins.win/raw (original)
                { url: `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`, parser: (data) => data },
            ];

            let lastError = null;
            
            for (let i = 0; i < proxies.length; i++) {
                try {
                    const proxy = proxies[i];
                    const response = await fetch(proxy.url, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    let data = await response.json();
                    
                    // Parse if needed
                    if (proxy.parser) {
                        data = proxy.parser(data);
                    }
                    
                    if (!data.chart || !data.chart.result || !data.chart.result[0]) {
                        throw new Error('Invalid data structure');
                    }

                    const result = data.chart.result[0];
                    const timestamps = result.timestamp;
                    const quote = result.indicators.quote[0];

                    if (!timestamps || !quote) {
                        throw new Error('Missing timestamp or quote data');
                    }

                    const ohlc = [];
                    for (let i = 0; i < timestamps.length; i++) {
                        if (quote.open[i] != null && quote.high[i] != null && quote.low[i] != null && quote.close[i] != null) {
                            ohlc.push({
                                date: new Date(timestamps[i] * 1000),
                                open: quote.open[i],
                                high: quote.high[i],
                                low: quote.low[i],
                                close: quote.close[i],
                                volume: quote.volume[i] || 0
                            });
                        }
                    }

                    if (ohlc.length === 0) {
                        throw new Error('No valid OHLC data');
                    }

                    console.log(`Successfully fetched data via proxy ${i + 1}`);
                    return ohlc;
                } catch (error) {
                    console.warn(`Proxy ${i + 1} failed:`, error.message);
                    lastError = error;
                    // Continue to next proxy
                    continue;
                }
            }

            // All proxies failed
            throw new Error(`All CORS proxies failed. Last error: ${lastError?.message || 'Unknown error'}. 
Please try:
1. Use Alpha Vantage API (requires free API key from alphavantage.co)
2. Install a CORS browser extension (e.g., "CORS Unblock" or "Allow CORS")
3. Run a local CORS proxy server`);
        }

        async function fetchAlphaVantageData(ticker, interval = '1d', apiKey) {
            if (!apiKey) {
                throw new Error('Alpha Vantage API key required. Get a free key at alphavantage.co');
            }

            let url, timeSeriesKey;
            
            // Use appropriate Alpha Vantage function based on interval
            if (interval === '1d') {
                url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${ticker}&apikey=${apiKey}&outputsize=full`;
                timeSeriesKey = 'Time Series (Daily)';
            } else if (interval === '1wk') {
                url = `https://www.alphavantage.co/query?function=TIME_SERIES_WEEKLY&symbol=${ticker}&apikey=${apiKey}&outputsize=full`;
                timeSeriesKey = 'Weekly Time Series';
            } else if (interval === '1mo') {
                url = `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY&symbol=${ticker}&apikey=${apiKey}&outputsize=full`;
                timeSeriesKey = 'Monthly Time Series';
            } else {
                // Intraday (5m, 15m, 1h)
                const intervalMap = {
                    '5m': '5min',
                    '15m': '15min',
                    '1h': '60min'
                };
                const avInterval = intervalMap[interval] || '5min';
                url = `https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=${ticker}&interval=${avInterval}&apikey=${apiKey}&outputsize=full`;
                timeSeriesKey = `Time Series (${avInterval})`;
            }

            try {
                const response = await fetch(url);
                const data = await response.json();

                // Check for API errors
                if (data['Error Message']) {
                    throw new Error(`Alpha Vantage Error: ${data['Error Message']}`);
                }
                if (data['Note']) {
                    throw new Error(`Alpha Vantage API Limit: ${data['Note']}. Please wait a moment and try again.`);
                }

                if (!data[timeSeriesKey]) {
                    throw new Error(`No time series data found. Available keys: ${Object.keys(data).join(', ')}`);
                }

                const timeSeries = data[timeSeriesKey];
                const ohlc = [];

                for (const [dateStr, values] of Object.entries(timeSeries)) {
                    // Parse date - Alpha Vantage uses format like "2024-01-15" or "2024-01-15 16:00:00"
                    let date = new Date(dateStr);
                    if (isNaN(date.getTime())) {
                        // Try parsing as timestamp if date string doesn't work
                        date = new Date(dateStr.replace(/(\d{4})-(\d{2})-(\d{2})(?:\s+(\d{2}):(\d{2}):(\d{2}))?/, '$1-$2-$3T$4:$5:$6'));
                    }
                    
                    ohlc.push({
                        date: date,
                        open: parseFloat(values['1. open'] || values['open']),
                        high: parseFloat(values['2. high'] || values['high']),
                        low: parseFloat(values['3. low'] || values['low']),
                        close: parseFloat(values['4. close'] || values['close']),
                        volume: parseFloat(values['5. volume'] || values['volume'] || 0)
                    });
                }

                if (ohlc.length === 0) {
                    throw new Error('No valid OHLC data returned');
                }

                return ohlc.sort((a, b) => a.date - b.date);
            } catch (error) {
                console.error('Alpha Vantage fetch error:', error);
                throw error;
            }
        }

        async function loadData() {
            const ticker = document.getElementById('tickerInput').value.trim().toUpperCase();
            if (!ticker) {
                alert('Please enter a ticker symbol');
                return;
            }

            currentTicker = ticker;
            const dataSource = document.getElementById('dataSource').value;
            const timeframe = document.getElementById('timeframe').value;
            const periodDays = parseInt(document.getElementById('periodDays').value);
            const loadingStatus = document.getElementById('loadingStatus');
            
            loadingStatus.style.display = 'block';
            loadingStatus.textContent = 'Loading data...';

            try {
                let ohlc;
                
                if (dataSource === 'Alpha Vantage') {
                    const apiKey = document.getElementById('apiKey').value.trim();
                    ohlc = await fetchAlphaVantageData(ticker, timeframe, apiKey);
                } else {
                    ohlc = await fetchYahooFinanceData(ticker, timeframe, Math.min(periodDays, 365));
                }

                if (!ohlc || ohlc.length === 0) {
                    throw new Error('No data received');
                }

                // Limit to 500 candles for 5m interval
                if (timeframe === '5m' && ohlc.length > 500) {
                    ohlc = ohlc.slice(-500);
                }

                currentData = ohlc;
                
                // Check alerts for this ticker
                const triggeredAlerts = checkAlerts(ticker, ohlc);
                if (triggeredAlerts.length > 0) {
                    let alertMsg = 'üîî Alerts Triggered:\n\n';
                    triggeredAlerts.forEach(alert => {
                        alertMsg += `‚Ä¢ ${alert.message}\n`;
                    });
                    alert(alertMsg);
                }
                
                renderChart();
                updateMetrics();
                loadingStatus.style.display = 'none';
                saveSettings();
            } catch (error) {
                loadingStatus.style.display = 'none';
                
                // Show error but keep existing content
                const errorHtml = `
                    <div class="error" style="margin-bottom: 20px;">
                        <h3 style="color: #f44336; margin-bottom: 10px;">Error Loading Data</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <hr style="margin: 15px 0; border-color: rgba(244, 67, 54, 0.3);">
                        <h4 style="color: #00d4ff; margin-top: 15px; margin-bottom: 10px;">Solutions:</h4>
                        <ol style="margin-left: 20px; line-height: 1.8;">
                            <li><strong>Use Alpha Vantage API:</strong> Switch to "Alpha Vantage" data source and get a free API key from <a href="https://www.alphavantage.co/support/#api-key" target="_blank" style="color: #00d4ff;">alphavantage.co</a></li>
                            <li><strong>Install CORS Extension:</strong> Install a browser extension like "CORS Unblock" or "Allow CORS: Access-Control-Allow-Origin"</li>
                            <li><strong>Wait and Retry:</strong> Some CORS proxies may be temporarily unavailable - try again in a few seconds</li>
                            <li><strong>Use Different Ticker:</strong> Try a different ticker symbol (e.g., SPY, AAPL, MSFT)</li>
                        </ol>
                    </div>
                `;
                
                // Insert error at top of content, but keep existing chart if any
                const tabContent = document.getElementById('tabContent');
                if (tabContent.querySelector('#trackerTab')) {
                    // Chart already exists, prepend error
                    const trackerTab = tabContent.querySelector('#trackerTab');
                    trackerTab.insertAdjacentHTML('afterbegin', errorHtml);
                } else {
                    // No chart yet, replace content
                    tabContent.innerHTML = errorHtml + `
                        <div id="trackerTab">
                            <div class="chart-container" id="chart"></div>
                            <div class="metrics" id="metrics"></div>
                        </div>
                    `;
                }
            }
        }

        // Chart rendering
        function renderChart() {
            if (!currentData || currentData.length === 0) return;

            const theme = document.querySelector('input[name="theme"]:checked').value;
            const isDark = theme === 'Dark';
            const closePrices = currentData.map(d => d.close);
            const dates = currentData.map(d => d.date);

            // Calculate indicators
            const sma20 = sma(closePrices, 20);
            const sma200 = sma(closePrices, 200);
            const ema20 = document.getElementById('showEMA').checked ? ema(closePrices, 20) : null;
            const rsiValues = document.getElementById('showRSI').checked ? rsi(closePrices, 14) : null;
            
            const macdMode = document.querySelector('input[name="macdMode"]:checked').value;
            const macdWindow = parseInt(document.getElementById('macdSidewaysWindow').value);
            const macdThreshold = parseFloat(document.getElementById('macdSidewaysThreshold').value) / 100;
            const macdData = document.getElementById('showMACD').checked ? 
                (macdMode === 'Extended' ? 
                    macdExtended(closePrices, 12, 26, 9, macdWindow, macdThreshold) : 
                    macd(closePrices, 12, 26, 9)) : null;

            const bbData = document.getElementById('showBollinger').checked ? bollingerBands(closePrices, 20, 2.0) : null;
            
            const high = currentData.map(d => d.high);
            const low = currentData.map(d => d.low);
            const supertrendData = document.getElementById('showSupertrend').checked ? 
                supertrend(high, low, closePrices, 10, 3.0) : null;

            const fvgs = document.getElementById('showFVG').checked ? findFairValueGaps(currentData) : [];

            // Create traces
            const traces = [];

            // Candlestick
            traces.push({
                x: dates,
                open: currentData.map(d => d.open),
                high: currentData.map(d => d.high),
                low: currentData.map(d => d.low),
                close: currentData.map(d => d.close),
                type: 'candlestick',
                name: 'Price',
                increasing: { line: { color: '#00ff88' } },
                decreasing: { line: { color: '#f44336' } }
            });

            // SMA 20
            if (document.getElementById('showSMA20').checked) {
                traces.push({
                    x: dates,
                    y: sma20,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'SMA 20',
                    line: { color: '#4fa3ff', width: 2 }
                });
            }

            // SMA 200
            if (document.getElementById('showSMA200').checked) {
                traces.push({
                    x: dates,
                    y: sma200,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'SMA 200',
                    line: { color: '#ff6b6b', width: 2 }
                });
            }

            // EMA 20
            if (ema20) {
                traces.push({
                    x: dates,
                    y: ema20,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'EMA 20',
                    line: { color: '#00ff88', width: 2, dash: 'dot' }
                });
            }

            // Bollinger Bands
            if (bbData) {
                traces.push({
                    x: dates,
                    y: bbData.upper,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'BB Upper',
                    line: { color: '#888', width: 1 },
                    showlegend: false
                });
                traces.push({
                    x: dates,
                    y: bbData.middle,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'BB Middle',
                    line: { color: '#888', width: 1 }
                });
                traces.push({
                    x: dates,
                    y: bbData.lower,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'BB Lower',
                    line: { color: '#888', width: 1 },
                    showlegend: false
                });
            }

            // Supertrend
            if (supertrendData) {
                const supertrendLine = supertrendData.supertrend;
                const uptrendDates = [];
                const uptrendValues = [];
                const downtrendDates = [];
                const downtrendValues = [];

                for (let i = 0; i < supertrendLine.length; i++) {
                    if (!isNaN(supertrendLine[i])) {
                        if (supertrendData.trend[i] > 0) {
                            uptrendDates.push(dates[i]);
                            uptrendValues.push(supertrendLine[i]);
                        } else {
                            downtrendDates.push(dates[i]);
                            downtrendValues.push(supertrendLine[i]);
                        }
                    }
                }

                if (uptrendDates.length > 0) {
                    traces.push({
                        x: uptrendDates,
                        y: uptrendValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Supertrend (Bullish)',
                        line: { color: '#00ff88', width: 2 }
                    });
                }

                if (downtrendDates.length > 0) {
                    traces.push({
                        x: downtrendDates,
                        y: downtrendValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Supertrend (Bearish)',
                        line: { color: '#f44336', width: 2 }
                    });
                }
            }

            // Fair Value Gaps (as shapes)
            const shapes = [];
            fvgs.forEach(fvg => {
                const color = fvg.type === 'bullish' ? 'rgba(0, 255, 136, 0.2)' : 'rgba(244, 67, 54, 0.2)';
                shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'y',
                    x0: fvg.start_date,
                    x1: fvg.end_date,
                    y0: fvg.gap_low,
                    y1: fvg.gap_high,
                    fillcolor: color,
                    line: { width: 0 },
                    layer: 'below'
                });
            });

            // Detect crosses
            const goldenCrosses = [];
            const deathCrosses = [];
            for (let i = 1; i < dates.length; i++) {
                if (!isNaN(sma20[i]) && !isNaN(sma200[i]) && 
                    !isNaN(sma20[i-1]) && !isNaN(sma200[i-1])) {
                    if (sma20[i-1] <= sma200[i-1] && sma20[i] > sma200[i]) {
                        goldenCrosses.push({ x: dates[i], y: closePrices[i] });
                    }
                    if (sma20[i-1] >= sma200[i-1] && sma20[i] < sma200[i]) {
                        deathCrosses.push({ x: dates[i], y: closePrices[i] });
                    }
                }
            }

            if (goldenCrosses.length > 0) {
                traces.push({
                    x: goldenCrosses.map(c => c.x),
                    y: goldenCrosses.map(c => c.y),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Golden Cross',
                    marker: { symbol: 'triangle-up', size: 25, color: '#17c964', line: { width: 1, color: '#0b3820' } }
                });
            }

            if (deathCrosses.length > 0) {
                traces.push({
                    x: deathCrosses.map(c => c.x),
                    y: deathCrosses.map(c => c.y),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Death Cross',
                    marker: { symbol: 'triangle-down', size: 25, color: '#f31260', line: { width: 1, color: '#4a0b19' } }
                });
            }

            // Volume subplot
            let volumeTrace = null;
            if (document.getElementById('showVolume').checked) {
                volumeTrace = {
                    x: dates,
                    y: currentData.map(d => d.volume),
                    type: 'bar',
                    name: 'Volume',
                    marker: { color: 'rgba(0, 212, 255, 0.5)' }
                };
            }

            // RSI subplot
            let rsiTrace = null;
            if (rsiValues) {
                rsiTrace = {
                    x: dates,
                    y: rsiValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'RSI',
                    line: { color: '#ff9800', width: 2 }
                };
            }

            // MACD subplot
            let macdTraces = [];
            if (macdData) {
                macdTraces = [
                    {
                        x: dates,
                        y: macdData.macdLine,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'MACD',
                        line: { color: '#00d4ff', width: 2 }
                    },
                    {
                        x: dates,
                        y: macdData.signalLine,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Signal',
                        line: { color: '#ff9800', width: 2 }
                    },
                    {
                        x: dates,
                        y: macdData.histogram,
                        type: 'bar',
                        name: 'Histogram',
                        marker: { color: macdData.histogram.map(h => h >= 0 ? '#00ff88' : '#f44336') }
                    }
                ];
            }

            // Create subplots
            const rows = 1 + (volumeTrace ? 1 : 0) + (rsiTrace ? 1 : 0) + (macdTraces.length > 0 ? 1 : 0);
            const specs = [{ rows: 2, cols: 1 }];
            if (volumeTrace) specs.push({ rows: 1, cols: 1 });
            if (rsiTrace) specs.push({ rows: 1, cols: 1 });
            if (macdTraces.length > 0) specs.push({ rows: 1, cols: 1 });

            // Add trade visualization shapes if trade params exist
            if (tradeParams && tradeParams.entry && tradeParams.stopLoss && tradeParams.target) {
                const startDate = dates[0];
                const endDate = dates[dates.length - 1];
                const direction = tradeParams.direction;
                const entry = tradeParams.entry;
                const stopLoss = tradeParams.stopLoss;
                const target = tradeParams.target;

                if (direction === 'LONG') {
                    // Red rectangle (risk zone: stop_loss to entry)
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'y',
                        x0: startDate,
                        y0: stopLoss,
                        x1: endDate,
                        y1: entry,
                        fillcolor: 'rgba(243, 18, 96, 0.2)',
                        line: { color: '#f31260', width: 1, dash: 'dot' },
                        layer: 'below'
                    });
                    // Green rectangle (reward zone: entry to target)
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'y',
                        x0: startDate,
                        y0: entry,
                        x1: endDate,
                        y1: target,
                        fillcolor: 'rgba(0, 255, 136, 0.2)',
                        line: { color: '#00ff88', width: 1, dash: 'dot' },
                        layer: 'below'
                    });
                } else if (direction === 'SHORT') {
                    // Red rectangle (risk zone: entry to stop_loss)
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'y',
                        x0: startDate,
                        y0: entry,
                        x1: endDate,
                        y1: stopLoss,
                        fillcolor: 'rgba(243, 18, 96, 0.2)',
                        line: { color: '#f31260', width: 1, dash: 'dot' },
                        layer: 'below'
                    });
                    // Green rectangle (reward zone: target to entry)
                    shapes.push({
                        type: 'rect',
                        xref: 'x',
                        yref: 'y',
                        x0: startDate,
                        y0: target,
                        x1: endDate,
                        y1: entry,
                        fillcolor: 'rgba(0, 255, 136, 0.2)',
                        line: { color: '#00ff88', width: 1, dash: 'dot' },
                        layer: 'below'
                    });
                }

                // Add horizontal lines for entry, stop loss, and target
                traces.push({
                    x: [startDate, endDate],
                    y: [entry, entry],
                    type: 'scatter',
                    mode: 'lines',
                    name: `Entry: $${entry.toFixed(2)}`,
                    line: { color: '#00ff88', width: 2, dash: 'solid' },
                    showlegend: true,
                    hoverinfo: 'y',
                    hovertemplate: `Entry: $${entry.toFixed(2)}<extra></extra>`
                });

                traces.push({
                    x: [startDate, endDate],
                    y: [stopLoss, stopLoss],
                    type: 'scatter',
                    mode: 'lines',
                    name: `Stop Loss: $${stopLoss.toFixed(2)}`,
                    line: { color: '#ff4444', width: 1.5, dash: 'dot' },
                    showlegend: true,
                    hoverinfo: 'y',
                    hovertemplate: `Stop Loss: $${stopLoss.toFixed(2)}<extra></extra>`
                });

                traces.push({
                    x: [startDate, endDate],
                    y: [target, target],
                    type: 'scatter',
                    mode: 'lines',
                    name: `Target: $${target.toFixed(2)}`,
                    line: { color: '#00ff88', width: 1.5, dash: 'dot' },
                    showlegend: true,
                    hoverinfo: 'y',
                    hovertemplate: `Target: $${target.toFixed(2)}<extra></extra>`
                });
            }

            const layout = {
                template: isDark ? 'plotly_dark' : 'plotly_white',
                title: `${currentTicker} - ${document.getElementById('timeframe').value}`,
                xaxis: { title: 'Date' },
                yaxis: { title: 'Price' },
                shapes: shapes,
                hovermode: 'x unified',
                height: 600,
                // Set black background for dark mode
                plot_bgcolor: isDark ? '#000000' : '#ffffff',
                paper_bgcolor: isDark ? '#000000' : '#ffffff'
            };

            // Use subplots if we have multiple indicators
            const chartElement = document.getElementById('chart');
            if (!chartElement) {
                console.warn('Chart element not found');
                return;
            }

            // Purge any existing plot to prevent duplicates
            Plotly.purge(chartElement);
            
            // Clear any existing content in chart element (in case of leftover divs)
            chartElement.innerHTML = '';

            // Build all traces for subplots
            const allTraces = [];
            
            // Main price chart (row 1)
            allTraces.push(...traces);
            
            // Volume subplot (row 2)
            if (volumeTrace) {
                allTraces.push(volumeTrace);
            }
            
            // RSI subplot
            if (rsiTrace) {
                allTraces.push(rsiTrace);
            }
            
            // MACD subplot
            if (macdTraces.length > 0) {
                allTraces.push(...macdTraces);
            }

            if (rows > 1) {
                // Configure subplot axes
                const subplotAxes = {};
                let currentRow = 1;
                
                // Main price chart uses xaxis and yaxis
                subplotAxes['xaxis'] = { ...layout.xaxis };
                subplotAxes['yaxis'] = { ...layout.yaxis };
                
                // Volume subplot
                if (volumeTrace) {
                    currentRow++;
                    subplotAxes[`xaxis${currentRow}`] = { ...layout.xaxis };
                    subplotAxes[`yaxis${currentRow}`] = { title: 'Volume' };
                }
                
                // RSI subplot
                if (rsiTrace) {
                    currentRow++;
                    subplotAxes[`xaxis${currentRow}`] = { ...layout.xaxis };
                    subplotAxes[`yaxis${currentRow}`] = { title: 'RSI', range: [0, 100] };
                }
                
                // MACD subplot
                if (macdTraces.length > 0) {
                    currentRow++;
                    subplotAxes[`xaxis${currentRow}`] = { ...layout.xaxis };
                    subplotAxes[`yaxis${currentRow}`] = { title: 'MACD' };
                }
                
                layout = {
                    ...layout,
                    ...subplotAxes,
                    grid: { 
                        rows: rows, 
                        columns: 1, 
                        pattern: 'independent',
                        roworder: 'top to bottom'
                    }
                };
                
                // Assign traces to subplots
                let traceIndex = 0;
                // Main chart traces go to row 1
                const mainChartTraceCount = traces.length;
                for (let i = 0; i < mainChartTraceCount; i++) {
                    allTraces[traceIndex].xaxis = 'x';
                    allTraces[traceIndex].yaxis = 'y';
                    traceIndex++;
                }
                
                currentRow = 1;
                // Volume
                if (volumeTrace) {
                    currentRow++;
                    allTraces[traceIndex].xaxis = `x${currentRow}`;
                    allTraces[traceIndex].yaxis = `y${currentRow}`;
                    traceIndex++;
                }
                
                // RSI
                if (rsiTrace) {
                    currentRow++;
                    allTraces[traceIndex].xaxis = `x${currentRow}`;
                    allTraces[traceIndex].yaxis = `y${currentRow}`;
                    traceIndex++;
                }
                
                // MACD
                if (macdTraces.length > 0) {
                    currentRow++;
                    for (let i = 0; i < macdTraces.length; i++) {
                        allTraces[traceIndex].xaxis = `x${currentRow}`;
                        allTraces[traceIndex].yaxis = `y${currentRow}`;
                        traceIndex++;
                    }
                }
                
                Plotly.newPlot(chartElement, allTraces, layout, {responsive: true});
            } else {
                // Single chart - no subplots needed
                Plotly.newPlot(chartElement, traces, layout, {responsive: true});
            }
        }

        function updateMetrics() {
            if (!currentData || currentData.length === 0) return;

            const last = currentData[currentData.length - 1];
            const closePrices = currentData.map(d => d.close);
            const sma20Values = sma(closePrices, 20);
            const sma200Values = sma(closePrices, 200);
            
            const currentPrice = last.close;
            const sma20Val = sma20Values[sma20Values.length - 1];
            const sma200Val = sma200Values[sma200Values.length - 1];
            
            const distToSMA20 = ((currentPrice - sma20Val) / sma20Val * 100).toFixed(2);
            const distToSMA200 = ((currentPrice - sma200Val) / sma200Val * 100).toFixed(2);
            
            const trend = sma20Val > sma200Val ? 'Bullish' : 'Bearish';
            
            document.getElementById('metrics').innerHTML = `
                <div class="metric">
                    <div class="metric-label">Current Price</div>
                    <div class="metric-value">$${currentPrice.toFixed(2)}</div>
                </div>
                <div class="metric">
                    <div class="metric-label">SMA 20</div>
                    <div class="metric-value">$${sma20Val.toFixed(2)}</div>
                    <div class="metric-delta">${distToSMA20 > 0 ? '+' : ''}${distToSMA20}%</div>
                </div>
                <div class="metric">
                    <div class="metric-label">SMA 200</div>
                    <div class="metric-value">$${sma200Val.toFixed(2)}</div>
                    <div class="metric-delta">${distToSMA200 > 0 ? '+' : ''}${distToSMA200}%</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Trend</div>
                    <div class="metric-value">${trend}</div>
                </div>
            `;
        }

        // AI Recommendation
        function generateAIRecommendation() {
            if (!currentData || currentData.length < 200) {
                alert('Insufficient data for AI analysis. Need at least 200 data points.');
                return;
            }

            const closePrices = currentData.map(d => d.close);
            const high = currentData.map(d => d.high);
            const low = currentData.map(d => d.low);
            
            const sma20Values = sma(closePrices, 20);
            const sma200Values = sma(closePrices, 200);
            const rsiValues = rsi(closePrices, 14);
            
            const macdMode = document.querySelector('input[name="macdMode"]:checked').value;
            const macdWindow = parseInt(document.getElementById('macdSidewaysWindow').value);
            const macdThreshold = parseFloat(document.getElementById('macdSidewaysThreshold').value) / 100;
            const macdData = macdMode === 'Extended' ? 
                macdExtended(closePrices, 12, 26, 9, macdWindow, macdThreshold) : 
                macd(closePrices, 12, 26, 9);
            
            const supertrendData = supertrend(high, low, closePrices, 10, 3.0);
            const fvgs = findFairValueGaps(currentData);

            // Get last values
            const lastIdx = closePrices.length - 1;
            const prevIdx = lastIdx - 1;
            const currentPrice = closePrices[lastIdx];
            const sma20Val = sma20Values[lastIdx];
            const sma200Val = sma200Values[lastIdx];
            const rsiVal = rsiValues[lastIdx] || 50;
            const macdVal = macdData.macdLine[lastIdx] || 0;
            const signalVal = macdData.signalLine[lastIdx] || 0;
            const macdHist = macdData.histogram[lastIdx] || 0;
            const trendCurrent = supertrendData.trend[lastIdx];

            // Scoring
            let totalScore = 0;
            const analysis = [];

            // SMA Analysis
            if (document.getElementById('useSMA_AI').checked) {
                let smaScore = 0;
                if (sma20Val > sma200Val) {
                    smaScore = sma20Values[prevIdx] <= sma200Values[prevIdx] ? 3 : 2;
                    analysis.push({ indicator: 'SMA', status: smaScore === 3 ? 'Golden Cross!' : 'Bullish', score: smaScore });
                } else {
                    smaScore = sma20Values[prevIdx] >= sma200Values[prevIdx] ? -3 : -2;
                    analysis.push({ indicator: 'SMA', status: smaScore === -3 ? 'Death Cross!' : 'Bearish', score: smaScore });
                }
                totalScore += smaScore;
            }

            // RSI Analysis
            if (document.getElementById('useRSI_AI').checked) {
                let rsiScore = 0;
                if (rsiVal < 30) {
                    rsiScore = 2;
                    analysis.push({ indicator: 'RSI', status: 'Oversold', score: rsiScore });
                } else if (rsiVal > 70) {
                    rsiScore = -2;
                    analysis.push({ indicator: 'RSI', status: 'Overbought', score: rsiScore });
                } else if (rsiVal <= 50) {
                    rsiScore = 1;
                    analysis.push({ indicator: 'RSI', status: 'Neutral-Bullish', score: rsiScore });
                } else {
                    rsiScore = -1;
                    analysis.push({ indicator: 'RSI', status: 'Neutral-Bearish', score: rsiScore });
                }
                totalScore += rsiScore;
            }

            // MACD Analysis
            if (document.getElementById('useMACD_AI').checked) {
                let macdScore = 0;
                const macdAboveSignal = macdVal > signalVal;
                const macdAboveSignalPrev = macdData.macdLine[prevIdx] > macdData.signalLine[prevIdx];
                
                if (macdAboveSignal && !macdAboveSignalPrev) {
                    macdScore = 3;
                    analysis.push({ indicator: 'MACD', status: 'Bullish Crossover!', score: macdScore });
                } else if (!macdAboveSignal && macdAboveSignalPrev) {
                    macdScore = -3;
                    analysis.push({ indicator: 'MACD', status: 'Bearish Crossover!', score: macdScore });
                } else if (macdAboveSignal) {
                    macdScore = macdHist > 0 ? 2 : 1;
                    analysis.push({ indicator: 'MACD', status: 'Bullish', score: macdScore });
                } else {
                    macdScore = macdHist < 0 ? -2 : -1;
                    analysis.push({ indicator: 'MACD', status: 'Bearish', score: macdScore });
                }
                totalScore += macdScore;
            }

            // Supertrend Analysis
            if (document.getElementById('useSupertrend_AI').checked) {
                let supertrendScore = 0;
                if (trendCurrent > 0) {
                    supertrendScore = supertrendData.trend[prevIdx] <= 0 ? 3 : 2;
                    analysis.push({ indicator: 'Supertrend', status: 'Bullish', score: supertrendScore });
                } else {
                    supertrendScore = supertrendData.trend[prevIdx] >= 0 ? -3 : -2;
                    analysis.push({ indicator: 'Supertrend', status: 'Bearish', score: supertrendScore });
                }
                totalScore += supertrendScore;
            }

            // FVG Analysis
            if (document.getElementById('useFVG_AI').checked) {
                const recentFvgs = fvgs.slice(-3);
                const bullishFvgs = recentFvgs.filter(f => f.type === 'bullish');
                const bearishFvgs = recentFvgs.filter(f => f.type === 'bearish');
                
                let fvgScore = bullishFvgs.length > bearishFvgs.length ? 1 : (bearishFvgs.length > bullishFvgs.length ? -1 : 0);
                totalScore += fvgScore;
                analysis.push({ indicator: 'FVG', status: `${bullishFvgs.length} bullish, ${bearishFvgs.length} bearish`, score: fvgScore });
            }

            // Determine recommendation
            let recommendation, direction, confidence;
            if (totalScore >= 5) {
                recommendation = 'STRONG LONG';
                direction = 'LONG';
                confidence = 'HIGH';
            } else if (totalScore >= 2) {
                recommendation = 'LONG';
                direction = 'LONG';
                confidence = 'MEDIUM';
            } else if (totalScore <= -5) {
                recommendation = 'STRONG SHORT';
                direction = 'SHORT';
                confidence = 'HIGH';
            } else if (totalScore <= -2) {
                recommendation = 'SHORT';
                direction = 'SHORT';
                confidence = 'MEDIUM';
            } else {
                recommendation = 'NEUTRAL';
                direction = 'NEUTRAL';
                confidence = 'LOW';
            }

            // Calculate trade parameters (entry, stop loss, target)
            const entryPrice = currentPrice;
            const atrStop = calculateATRStopLoss(high, low, closePrices, 2.0, direction === 'LONG');
            
            let stopLoss, targetPrice;
            
            if (direction === 'LONG') {
                // For long positions
                stopLoss = Math.min(atrStop || (currentPrice * 0.95), currentPrice * 0.95); // Use ATR or 5% whichever is closer
                targetPrice = currentPrice * 1.10; // 10% target initially
                
                // Ensure minimum 2:1 risk/reward
                const risk = Math.abs(entryPrice - stopLoss);
                const reward = Math.abs(targetPrice - entryPrice);
                if (reward / risk < 2.0 && risk > 0) {
                    targetPrice = entryPrice + (risk * 2.0);
                }
            } else if (direction === 'SHORT') {
                // For short positions
                stopLoss = Math.max(atrStop || (currentPrice * 1.05), currentPrice * 1.05); // Use ATR or 5% whichever is closer
                targetPrice = currentPrice * 0.90; // 10% target initially
                
                // Ensure minimum 2:1 risk/reward
                const risk = Math.abs(stopLoss - entryPrice);
                const reward = Math.abs(entryPrice - targetPrice);
                if (reward / risk < 2.0 && risk > 0) {
                    targetPrice = entryPrice - (risk * 2.0);
                }
            } else {
                // Neutral/Hold
                stopLoss = currentPrice * 0.95;
                targetPrice = currentPrice * 1.05;
            }

            // Store trade parameters for chart visualization
            if (direction !== 'NEUTRAL') {
                tradeParams = {
                    entry: entryPrice,
                    stopLoss: stopLoss,
                    target: targetPrice,
                    direction: direction
                };
            } else {
                tradeParams = null;
            }

            // Calculate risk/reward ratio
            let risk, reward, riskRewardRatio;
            if (direction === 'LONG') {
                risk = Math.abs(entryPrice - stopLoss);
                reward = Math.abs(targetPrice - entryPrice);
                riskRewardRatio = reward / risk;
            } else if (direction === 'SHORT') {
                risk = Math.abs(stopLoss - entryPrice);
                reward = Math.abs(entryPrice - targetPrice);
                riskRewardRatio = reward / risk;
            } else {
                risk = 0;
                reward = 0;
                riskRewardRatio = 0;
            }

            // Display recommendation
            const signalClass = direction === 'LONG' ? 'signal-long' : (direction === 'SHORT' ? 'signal-short' : 'signal-neutral');
            document.getElementById('tabContent').innerHTML = `
                <div class="ai-recommendation">
                    <h3>AI Recommendation</h3>
                    <div style="font-size: 24px; margin-bottom: 20px;">
                        <span class="signal-badge ${signalClass}">${recommendation}</span>
                        <span style="color: #b0b0b0; margin-left: 10px;">Confidence: ${confidence}</span>
                    </div>
                    <div style="margin-bottom: 15px;"><strong>Total Score:</strong> ${totalScore}</div>
                    <div><strong>Analysis Breakdown:</strong></div>
                    <ul style="margin-top: 10px;">
                        ${analysis.map(a => `<li>${a.indicator}: ${a.status} (Score: ${a.score > 0 ? '+' : ''}${a.score})</li>`).join('')}
                    </ul>
                    <div style="margin-top: 20px;">
                        <strong>Current Price:</strong> $${currentPrice.toFixed(2)}<br>
                        <strong>SMA 20:</strong> $${sma20Val.toFixed(2)}<br>
                        <strong>SMA 200:</strong> $${sma200Val.toFixed(2)}<br>
                        <strong>RSI:</strong> ${rsiVal.toFixed(1)}
                    </div>
                    ${direction !== 'NEUTRAL' ? `
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0, 212, 255, 0.1); border-left: 4px solid #00d4ff; border-radius: 6px;">
                        <h4 style="color: #00d4ff; margin-bottom: 10px;">Trade Parameters</h4>
                        <strong>Entry:</strong> $${entryPrice.toFixed(2)}<br>
                        <strong>Stop Loss:</strong> $${stopLoss.toFixed(2)}<br>
                        <strong>Target:</strong> $${targetPrice.toFixed(2)}<br>
                        <strong>Risk:</strong> $${risk.toFixed(2)} (${((risk / entryPrice) * 100).toFixed(2)}%)<br>
                        <strong>Reward:</strong> $${reward.toFixed(2)} (${((reward / entryPrice) * 100).toFixed(2)}%)<br>
                        <strong>Risk/Reward Ratio:</strong> ${riskRewardRatio.toFixed(2)}:1
                    </div>
                    ` : ''}
                    <button onclick="switchTab(0)" style="margin-top: 20px;">View Chart with Trade Zones</button>
                </div>
            `;
            
            // Don't re-render chart here - let user click "View Chart with Trade Zones" button
            // The chart will be rendered when they switch to the tracker tab
        }

        // Tab switching - Now handles all 11 tabs
        function switchTab(index) {
            document.querySelectorAll('.tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });

            if (index === 0) {
                // Tracker tab
                let trackerTab = document.getElementById('tabContent').querySelector('#trackerTab');
                if (!trackerTab) {
                    document.getElementById('tabContent').innerHTML = `
                        <div id="trackerTab">
                            <div class="chart-container" id="chart"></div>
                            <div class="metrics" id="metrics"></div>
                        </div>
                    `;
                } else {
                    const errors = trackerTab.querySelectorAll('.error');
                    errors.forEach(e => e.remove());
                    if (!trackerTab.querySelector('#chart')) {
                        const metricsDiv = trackerTab.querySelector('#metrics');
                        const chartContainer = document.createElement('div');
                        chartContainer.className = 'chart-container';
                        chartContainer.id = 'chart';
                        if (metricsDiv) {
                            trackerTab.insertBefore(chartContainer, metricsDiv);
                        } else {
                            trackerTab.appendChild(chartContainer);
                        }
                    }
                }
                if (currentData) {
                    setTimeout(() => {
                        renderChart();
                        updateMetrics();
                    }, 50);
                }
            } else if (index === 1) {
                // Alerts tab
                renderAlertsTab();
            } else if (index === 2) {
                // Cross History tab
                renderCrossHistoryTab();
            } else if (index === 3) {
                // Portfolio tab
                renderPortfolioTab();
            } else if (index === 4) {
                // Backtesting tab
                renderBacktestingTab();
            } else if (index === 5) {
                // News tab
                renderNewsTab();
            } else if (index === 6) {
                // Patterns tab
                renderPatternsTab();
            } else if (index === 7) {
                // Correlation tab
                renderCorrelationTab();
            } else if (index === 8) {
                // Journal tab
                renderJournalTab();
            } else if (index === 9) {
                // Signals tab
                renderSignalsTab();
            } else if (index === 10) {
                // Risk tab
                renderRiskTab();
            } else if (index === 11) {
                // AI Recommendations tab
                if (currentData) {
                    generateAIRecommendation();
                } else {
                    document.getElementById('tabContent').innerHTML = '<div class="info-box">Please load data first.</div>';
                }
            }
        }

        // ========== NEW TAB FUNCTIONS ==========
        // Helper: Load/Save Alerts
        function loadAlerts() {
            const saved = localStorage.getItem('traderqAlerts');
            return saved ? JSON.parse(saved) : [];
        }

        function saveAlerts(alerts) {
            localStorage.setItem('traderqAlerts', JSON.stringify(alerts));
        }

        function loadAlertHistory() {
            const saved = localStorage.getItem('traderqAlertHistory');
            return saved ? JSON.parse(saved) : [];
        }

        function saveAlertHistory(history) {
            // Keep only last 50 alerts
            const trimmed = history.slice(-50);
            localStorage.setItem('traderqAlertHistory', JSON.stringify(trimmed));
        }

        function checkAlerts(ticker, df) {
            const alerts = loadAlerts();
            const history = loadAlertHistory();
            const activeAlerts = alerts.filter(a => a.enabled && a.ticker === ticker.toUpperCase());
            const triggered = [];
            
            if (!df || df.length === 0) return;
            
            const last = df[df.length - 1];
            const close = last.close;
            const sma20_vals = sma(df.map(d => d.close), 20);
            const sma200_vals = sma(df.map(d => d.close), 200);
            const sma20 = sma20_vals[sma20_vals.length - 1];
            const sma200 = sma200_vals[sma200_vals.length - 1];
            const rsi_vals = rsi(df.map(d => d.close), 14);
            const rsi_val = rsi_vals[rsi_vals.length - 1];
            
            // Previous values for cross detection
            if (df.length > 1) {
                const prev = df[df.length - 2];
                const prev_sma20 = sma20_vals[sma20_vals.length - 2];
                const prev_sma200 = sma200_vals[sma200_vals.length - 2];
                
                for (const alert of activeAlerts) {
                    let triggered_now = false;
                    let message = '';
                    
                    if (alert.type === 'golden_cross' && prev_sma20 <= prev_sma200 && sma20 > sma200) {
                        triggered_now = true;
                        message = `Golden Cross detected for ${alert.ticker} at $${close.toFixed(2)}`;
                    } else if (alert.type === 'death_cross' && prev_sma20 >= prev_sma200 && sma20 < sma200) {
                        triggered_now = true;
                        message = `Death Cross detected for ${alert.ticker} at $${close.toFixed(2)}`;
                    } else if (alert.type === 'price_above' && close >= alert.value) {
                        triggered_now = true;
                        message = `${alert.ticker} price ($${close.toFixed(2)}) is above $${alert.value.toFixed(2)}`;
                    } else if (alert.type === 'price_below' && close <= alert.value) {
                        triggered_now = true;
                        message = `${alert.ticker} price ($${close.toFixed(2)}) is below $${alert.value.toFixed(2)}`;
                    } else if (alert.type === 'rsi_overbought' && rsi_val >= alert.value) {
                        triggered_now = true;
                        message = `${alert.ticker} RSI (${rsi_val.toFixed(1)}) is overbought (>=${alert.value})`;
                    } else if (alert.type === 'rsi_oversold' && rsi_val <= alert.value) {
                        triggered_now = true;
                        message = `${alert.ticker} RSI (${rsi_val.toFixed(1)}) is oversold (<=${alert.value})`;
                    }
                    
                    if (triggered_now) {
                        // Check if already triggered recently (within last hour)
                        const recent = history.filter(h => 
                            h.ticker === alert.ticker && 
                            h.type === alert.type &&
                            Date.now() - new Date(h.timestamp).getTime() < 3600000
                        );
                        
                        if (recent.length === 0) {
                            const alertRecord = {
                                ticker: alert.ticker,
                                type: alert.type,
                                message: message,
                                timestamp: new Date().toISOString(),
                                email_sent: false
                            };
                            history.push(alertRecord);
                            triggered.push(alertRecord);
                        }
                    }
                }
            }
            
            if (triggered.length > 0) {
                saveAlertHistory(history);
            }
            
            return triggered;
        }

        // Render Alerts Tab
        function renderAlertsTab() {
            const alerts = loadAlerts();
            const history = loadAlertHistory().slice(-20).reverse();
            
            let html = `
                <h2>üîî Alerts & Notifications</h2>
                <p>Set up alerts for cross events, price levels, and RSI conditions.</p>
                
                ${alerts.length > 0 ? `
                    <h3>Active Alerts</h3>
                    <div style="margin-bottom: 20px;">
                ` : ''}
            `;
            
            alerts.forEach((alert, i) => {
                const alertTypes = {
                    'golden_cross': 'Golden Cross',
                    'death_cross': 'Death Cross',
                    'price_above': `Price Above $${alert.value ? alert.value.toFixed(2) : '0.00'}`,
                    'price_below': `Price Below $${alert.value ? alert.value.toFixed(2) : '0.00'}`,
                    'rsi_overbought': `RSI Overbought (‚â•${alert.value || 70})`,
                    'rsi_oversold': `RSI Oversold (‚â§${alert.value || 30})`
                };
                
                html += `
                    <div class="info-box" style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${alert.ticker}</strong> - ${alertTypes[alert.type] || alert.type}
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <span>${alert.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}</span>
                                <button onclick="toggleAlert(${i})" class="sidebar button" style="width: auto; padding: 5px 15px;">Toggle</button>
                                <button onclick="deleteAlert(${i})" class="sidebar button" style="width: auto; padding: 5px 15px; background: linear-gradient(90deg, #f31260 0%, #cc0d4d 100%);">Delete</button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            if (alerts.length > 0) {
                html += `</div><hr style="margin: 20px 0; border-color: rgba(0,212,255,0.3);">`;
            }
            
            html += `
                <h3>Add New Alert</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label>Ticker:</label>
                        <input type="text" id="alertTicker" placeholder="e.g., SPY" style="width: 100%;">
                    </div>
                    <div>
                        <label>Alert Type:</label>
                        <select id="alertType" style="width: 100%;">
                            <option value="golden_cross">Golden Cross</option>
                            <option value="death_cross">Death Cross</option>
                            <option value="price_above">Price Above</option>
                            <option value="price_below">Price Below</option>
                            <option value="rsi_overbought">RSI Overbought</option>
                            <option value="rsi_oversold">RSI Oversold</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label id="alertValueLabel">Threshold:</label>
                    <input type="number" id="alertValue" placeholder="0.00" step="0.01" style="width: 100%; margin-bottom: 15px;">
                </div>
                <button onclick="addAlert()" class="sidebar button">Add Alert</button>
                
                <hr style="margin: 30px 0; border-color: rgba(0,212,255,0.3);">
                <h3>üìú Alert History</h3>
            `;
            
            if (history.length > 0) {
                html += '<table style="width: 100%; border-collapse: collapse; margin-top: 15px;"><thead><tr style="border-bottom: 1px solid #00d4ff;"><th style="padding: 10px; text-align: left;">Time</th><th style="padding: 10px; text-align: left;">Ticker</th><th style="padding: 10px; text-align: left;">Message</th></tr></thead><tbody>';
                history.forEach(h => {
                    const time = new Date(h.timestamp).toLocaleString();
                    html += `<tr style="border-bottom: 1px solid rgba(0,212,255,0.2);"><td style="padding: 10px;">${time}</td><td style="padding: 10px;">${h.ticker}</td><td style="padding: 10px;">${h.message}</td></tr>`;
                });
                html += '</tbody></table>';
            } else {
                html += '<div class="info-box">No alert history yet.</div>';
            }
            
            document.getElementById('tabContent').innerHTML = html;
            
            // Update alert value label based on type
            document.getElementById('alertType').addEventListener('change', function() {
                const type = this.value;
                const label = document.getElementById('alertValueLabel');
                const input = document.getElementById('alertValue');
                if (type === 'price_above' || type === 'price_below') {
                    label.textContent = 'Price Threshold ($):';
                    input.value = '';
                } else if (type === 'rsi_overbought') {
                    label.textContent = 'RSI Threshold:';
                    input.value = '70';
                } else if (type === 'rsi_oversold') {
                    label.textContent = 'RSI Threshold:';
                    input.value = '30';
                } else {
                    label.textContent = 'Threshold:';
                    input.value = '';
                }
            });
        }

        function toggleAlert(index) {
            const alerts = loadAlerts();
            alerts[index].enabled = !alerts[index].enabled;
            saveAlerts(alerts);
            renderAlertsTab();
        }

        function deleteAlert(index) {
            const alerts = loadAlerts();
            alerts.splice(index, 1);
            saveAlerts(alerts);
            renderAlertsTab();
        }

        function addAlert() {
            const ticker = document.getElementById('alertTicker').value.trim().toUpperCase();
            const type = document.getElementById('alertType').value;
            const value = parseFloat(document.getElementById('alertValue').value);
            
            if (!ticker) {
                alert('Please enter a ticker symbol');
                return;
            }
            
            const alert = {
                ticker: ticker,
                type: type,
                enabled: true,
                created: new Date().toISOString()
            };
            
            if (type === 'price_above' || type === 'price_below' || type === 'rsi_overbought' || type === 'rsi_oversold') {
                if (isNaN(value) || value <= 0) {
                    alert('Please enter a valid threshold value');
                    return;
                }
                alert.value = value;
            }
            
            const alerts = loadAlerts();
            alerts.push(alert);
            saveAlerts(alerts);
            renderAlertsTab();
        }

        // Helper: Detect Crosses
        function detectCrosses(df) {
            if (!df || df.length < 200) return [];
            
            const sma20_vals = sma(df.map(d => d.close), 20);
            const sma200_vals = sma(df.map(d => d.close), 200);
            const crosses = [];
            
            for (let i = 200; i < df.length; i++) {
                if (isNaN(sma20_vals[i]) || isNaN(sma200_vals[i])) continue;
                if (i === 0) continue;
                
                const prev_sma20 = sma20_vals[i - 1];
                const prev_sma200 = sma200_vals[i - 1];
                const curr_sma20 = sma20_vals[i];
                const curr_sma200 = sma200_vals[i];
                
                // Golden Cross
                if (prev_sma20 <= prev_sma200 && curr_sma20 > curr_sma200) {
                    crosses.push({
                        date: df[i].date || new Date(df[i].timestamp || Date.now()).toISOString().split('T')[0],
                        type: 'Golden',
                        price: df[i].close,
                        sma20: curr_sma20,
                        sma200: curr_sma200
                    });
                }
                // Death Cross
                else if (prev_sma20 >= prev_sma200 && curr_sma20 < curr_sma200) {
                    crosses.push({
                        date: df[i].date || new Date(df[i].timestamp || Date.now()).toISOString().split('T')[0],
                        type: 'Death',
                        price: df[i].close,
                        sma20: curr_sma20,
                        sma200: curr_sma200
                    });
                }
            }
            
            return crosses;
        }

        function analyzeCrossPerformance(df, crosses, daysAfter) {
            if (!df || !crosses || crosses.length === 0) return crosses;
            
            return crosses.map(cross => {
                const crossDate = new Date(cross.date);
                let crossIdx = -1;
                
                // Find index of cross date
                for (let i = 0; i < df.length; i++) {
                    const dfDate = new Date(df[i].timestamp || df[i].date || Date.now());
                    if (Math.abs(dfDate - crossDate) < 86400000) { // Within 1 day
                        crossIdx = i;
                        break;
                    }
                }
                
                if (crossIdx < 0 || crossIdx >= df.length) {
                    cross.performance = null;
                    return cross;
                }
                
                const priceAtCross = df[crossIdx].close;
                const futureIdx = Math.min(crossIdx + daysAfter, df.length - 1);
                const priceAfter = df[futureIdx].close;
                const pctChange = ((priceAfter - priceAtCross) / priceAtCross) * 100;
                const daysActual = futureIdx - crossIdx;
                
                cross.performance = {
                    price_after: priceAfter,
                    pct_change: pctChange,
                    days_actual: daysActual,
                    days_target: daysAfter
                };
                
                return cross;
            });
        }

        // Render Cross History Tab
        function renderCrossHistoryTab() {
            let html = `
                <h2>üìä Historical Cross Analysis</h2>
                <p>Analyze past Golden and Death Cross events and their performance.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Select Ticker:</label>
                        <input type="text" id="crossHistoryTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                    <div>
                        <label>Analyze performance after (days):</label>
                        <input type="number" id="crossHistoryDays" value="30" min="7" max="180" step="7" style="width: 100%;">
                    </div>
                </div>
                <button onclick="analyzeCrosses()" class="sidebar button">Analyze Crosses</button>
                
                <div id="crossHistoryResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        async function analyzeCrosses() {
            const ticker = document.getElementById('crossHistoryTicker').value.trim().toUpperCase() || currentTicker;
            const daysAfter = parseInt(document.getElementById('crossHistoryDays').value) || 30;
            
            document.getElementById('crossHistoryResults').innerHTML = '<div class="loading">Loading data...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                
                let df;
                if (dataSource === 'Alpha Vantage') {
                    const apiKey = document.getElementById('apiKey').value;
                    if (!apiKey) {
                        throw new Error('Alpha Vantage API key required');
                    }
                    df = await fetchAlphaVantageData(ticker, interval, apiKey);
                } else {
                    df = await fetchYahooFinanceData(ticker, interval, periodDays);
                }
                
                if (!df || df.length === 0) {
                    throw new Error('No data available');
                }
                
                const crosses = detectCrosses(df);
                const crossesWithPerf = analyzeCrossPerformance(df, crosses, daysAfter);
                
                if (crossesWithPerf.length === 0) {
                    document.getElementById('crossHistoryResults').innerHTML = 
                        `<div class="info-box">No cross events found for ${ticker} in the selected period.</div>`;
                    return;
                }
                
                const goldenCrosses = crossesWithPerf.filter(c => c.type === 'Golden');
                const deathCrosses = crossesWithPerf.filter(c => c.type === 'Death');
                const avgGoldenReturn = goldenCrosses.length > 0 
                    ? goldenCrosses.reduce((sum, c) => sum + (c.performance ? c.performance.pct_change : 0), 0) / goldenCrosses.length
                    : 0;
                
                let resultsHtml = `
                    <h3>Cross Events for ${ticker}</h3>
                    <div class="metrics" style="margin: 20px 0;">
                        <div class="metric">
                            <div class="metric-label">Total Crosses</div>
                            <div class="metric-value">${crossesWithPerf.length}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Golden Crosses</div>
                            <div class="metric-value">${goldenCrosses.length}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Death Crosses</div>
                            <div class="metric-value">${deathCrosses.length}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Avg Golden Return</div>
                            <div class="metric-value">${avgGoldenReturn.toFixed(2)}%</div>
                        </div>
                    </div>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #00d4ff;">
                                <th style="padding: 10px; text-align: left;">Date</th>
                                <th style="padding: 10px; text-align: left;">Type</th>
                                <th style="padding: 10px; text-align: right;">Price at Cross</th>
                                <th style="padding: 10px; text-align: right;">SMA20</th>
                                <th style="padding: 10px; text-align: right;">SMA200</th>
                                <th style="padding: 10px; text-align: right;">Price After</th>
                                <th style="padding: 10px; text-align: right;">Return %</th>
                                <th style="padding: 10px; text-align: right;">Days</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                crossesWithPerf.forEach(cross => {
                    const perf = cross.performance;
                    resultsHtml += `
                        <tr style="border-bottom: 1px solid rgba(0,212,255,0.2);">
                            <td style="padding: 10px;">${cross.date}</td>
                            <td style="padding: 10px; color: ${cross.type === 'Golden' ? '#00ff88' : '#f31260'};">
                                ${cross.type}
                            </td>
                            <td style="padding: 10px; text-align: right;">$${cross.price.toFixed(2)}</td>
                            <td style="padding: 10px; text-align: right;">$${cross.sma20.toFixed(2)}</td>
                            <td style="padding: 10px; text-align: right;">$${cross.sma200.toFixed(2)}</td>
                            <td style="padding: 10px; text-align: right;">
                                ${perf ? `$${perf.price_after.toFixed(2)}` : 'N/A'}
                            </td>
                            <td style="padding: 10px; text-align: right; color: ${perf && perf.pct_change >= 0 ? '#00ff88' : '#f31260'};">
                                ${perf ? `${perf.pct_change >= 0 ? '+' : ''}${perf.pct_change.toFixed(2)}%` : 'N/A'}
                            </td>
                            <td style="padding: 10px; text-align: right;">
                                ${perf ? perf.days_actual : 'N/A'}
                            </td>
                        </tr>
                    `;
                });
                
                resultsHtml += '</tbody></table>';
                document.getElementById('crossHistoryResults').innerHTML = resultsHtml;
                
            } catch (error) {
                document.getElementById('crossHistoryResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Render Portfolio Tab
        function renderPortfolioTab() {
            const portfolio = loadPortfolio();
            
            let html = `
                <h2>üíº Portfolio Tracking</h2>
                <p>Track multiple tickers as a portfolio with custom weights.</p>
                
                <h3>Portfolio Tickers</h3>
                <input type="text" id="portfolioTickers" placeholder="e.g., SPY,AAPL,MSFT" value="${portfolio.tickers ? portfolio.tickers.join(',') : ''}" style="width: 100%; margin-bottom: 15px;">
                <p style="font-size: 12px; color: #888; margin-bottom: 15px;">Enter tickers separated by commas. Weights will be normalized to sum to 100%.</p>
                
                <div id="portfolioWeights" style="margin-bottom: 20px;"></div>
                
                <button onclick="updatePortfolio()" class="sidebar button" style="margin-right: 10px;">Update Portfolio</button>
                <button onclick="calculatePortfolioMetrics()" class="sidebar button">Calculate Portfolio Metrics</button>
                
                <div id="portfolioResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
            
            // Update weights display when tickers change
            document.getElementById('portfolioTickers').addEventListener('input', function() {
                updatePortfolioWeightsDisplay();
            });
            
            updatePortfolioWeightsDisplay();
        }

        function updatePortfolioWeightsDisplay() {
            const tickerInput = document.getElementById('portfolioTickers').value.trim();
            const tickers = tickerInput ? tickerInput.split(',').map(t => t.trim().toUpperCase()).filter(t => t) : [];
            const portfolio = loadPortfolio();
            
            if (tickers.length === 0) {
                document.getElementById('portfolioWeights').innerHTML = '';
                return;
            }
            
            let html = '<h3>Portfolio Weights</h3>';
            tickers.forEach(ticker => {
                const savedWeight = portfolio.weights && portfolio.weights[ticker] ? portfolio.weights[ticker] : (100 / tickers.length);
                html += `
                    <div style="margin-bottom: 10px;">
                        <label>${ticker} Weight (%):</label>
                        <input type="number" id="weight_${ticker}" value="${savedWeight.toFixed(1)}" min="0" max="100" step="0.1" style="width: 100%;">
                    </div>
                `;
            });
            
            document.getElementById('portfolioWeights').innerHTML = html;
        }

        function loadPortfolio() {
            const saved = localStorage.getItem('traderqPortfolio');
            return saved ? JSON.parse(saved) : { tickers: [], weights: {} };
        }

        function savePortfolio(portfolio) {
            localStorage.setItem('traderqPortfolio', JSON.stringify(portfolio));
        }

        function updatePortfolio() {
            const tickerInput = document.getElementById('portfolioTickers').value.trim();
            const tickers = tickerInput ? tickerInput.split(',').map(t => t.trim().toUpperCase()).filter(t => t) : [];
            
            if (tickers.length === 0) {
                alert('Please enter at least one ticker');
                return;
            }
            
            const weights = {};
            let totalWeight = 0;
            tickers.forEach(ticker => {
                const weight = parseFloat(document.getElementById(`weight_${ticker}`).value) || 0;
                weights[ticker] = weight;
                totalWeight += weight;
            });
            
            // Normalize weights
            if (totalWeight > 0) {
                Object.keys(weights).forEach(ticker => {
                    weights[ticker] = (weights[ticker] / totalWeight) * 100;
                });
            } else {
                // Equal weights if no weights specified
                const equalWeight = 100 / tickers.length;
                tickers.forEach(ticker => {
                    weights[ticker] = equalWeight;
                });
            }
            
            const portfolio = { tickers, weights };
            savePortfolio(portfolio);
            
            document.getElementById('portfolioResults').innerHTML = 
                '<div class="success-box">Portfolio updated successfully!</div>';
        }

        async function calculatePortfolioMetrics() {
            const portfolio = loadPortfolio();
            
            if (!portfolio.tickers || portfolio.tickers.length === 0) {
                alert('Please set up your portfolio first');
                return;
            }
            
            document.getElementById('portfolioResults').innerHTML = '<div class="loading">Calculating portfolio metrics...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                const apiKey = document.getElementById('apiKey').value;
                
                const dataMap = {};
                for (const ticker of portfolio.tickers) {
                    let df;
                    if (dataSource === 'Alpha Vantage') {
                        if (!apiKey) throw new Error('Alpha Vantage API key required');
                        df = await fetchAlphaVantageData(ticker, interval, apiKey);
                    } else {
                        df = await fetchYahooFinanceData(ticker, interval, periodDays);
                    }
                    
                    if (df && df.length > 0) {
                        dataMap[ticker] = df;
                    }
                }
                
                if (Object.keys(dataMap).length === 0) {
                    throw new Error('No data available for portfolio tickers');
                }
                
                // Calculate returns
                const returns = {};
                Object.keys(dataMap).forEach(ticker => {
                    const df = dataMap[ticker];
                    returns[ticker] = [];
                    for (let i = 1; i < df.length; i++) {
                        const ret = ((df[i].close - df[i-1].close) / df[i-1].close) * 100;
                        returns[ticker].push(ret);
                    }
                });
                
                // Calculate portfolio return
                const weights = portfolio.weights || {};
                let portfolioReturn = 0;
                let portfolioValue = 0;
                const individualReturns = {};
                
                Object.keys(returns).forEach(ticker => {
                    const tickerReturns = returns[ticker];
                    const avgReturn = tickerReturns.reduce((a, b) => a + b, 0) / tickerReturns.length;
                    const weight = (weights[ticker] || 0) / 100;
                    portfolioReturn += avgReturn * weight;
                    
                    const lastPrice = dataMap[ticker][dataMap[ticker].length - 1].close;
                    individualReturns[ticker] = {
                        return: avgReturn,
                        weight: weight * 100,
                        price: lastPrice
                    };
                    portfolioValue += lastPrice * weight;
                });
                
                let resultsHtml = `
                    <h3>Portfolio Performance</h3>
                    <div class="metrics" style="margin: 20px 0;">
                        <div class="metric">
                            <div class="metric-label">Portfolio Return</div>
                            <div class="metric-value">${portfolioReturn.toFixed(2)}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Number of Tickers</div>
                            <div class="metric-value">${portfolio.tickers.length}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Portfolio Value</div>
                            <div class="metric-value">$${portfolioValue.toFixed(2)}</div>
                        </div>
                    </div>
                    
                    <h3>Individual Performance</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #00d4ff;">
                                <th style="padding: 10px; text-align: left;">Ticker</th>
                                <th style="padding: 10px; text-align: right;">Weight</th>
                                <th style="padding: 10px; text-align: right;">Return</th>
                                <th style="padding: 10px; text-align: right;">Price</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                Object.keys(individualReturns).forEach(ticker => {
                    const perf = individualReturns[ticker];
                    resultsHtml += `
                        <tr style="border-bottom: 1px solid rgba(0,212,255,0.2);">
                            <td style="padding: 10px;">${ticker}</td>
                            <td style="padding: 10px; text-align: right;">${perf.weight.toFixed(1)}%</td>
                            <td style="padding: 10px; text-align: right; color: ${perf.return >= 0 ? '#00ff88' : '#f31260'};">
                                ${perf.return >= 0 ? '+' : ''}${perf.return.toFixed(2)}%
                            </td>
                            <td style="padding: 10px; text-align: right;">$${perf.price.toFixed(2)}</td>
                        </tr>
                    `;
                });
                
                resultsHtml += '</tbody></table>';
                document.getElementById('portfolioResults').innerHTML = resultsHtml;
                
            } catch (error) {
                document.getElementById('portfolioResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Render Backtesting Tab
        function renderBacktestingTab() {
            let html = `
                <h2>üß™ Strategy Backtesting</h2>
                <p>Test trading strategies based on SMA crosses and compare performance.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Select Ticker:</label>
                        <input type="text" id="backtestTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                    <div>
                        <label>Strategy:</label>
                        <select id="backtestStrategy" style="width: 100%;">
                            <option value="golden_death">Golden/Death Cross</option>
                            <option value="buy_hold">Buy and Hold</option>
                        </select>
                    </div>
                    <div>
                        <label>Initial Capital ($):</label>
                        <input type="number" id="backtestCapital" value="10000" min="1000" step="1000" style="width: 100%;">
                    </div>
                </div>
                
                <button onclick="runBacktest()" class="sidebar button">Run Backtest</button>
                
                <div id="backtestResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        async function runBacktest() {
            const ticker = document.getElementById('backtestTicker').value.trim().toUpperCase() || currentTicker;
            const strategy = document.getElementById('backtestStrategy').value;
            const initialCapital = parseFloat(document.getElementById('backtestCapital').value) || 10000;
            
            document.getElementById('backtestResults').innerHTML = '<div class="loading">Running backtest...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                const apiKey = document.getElementById('apiKey').value;
                
                let df;
                if (dataSource === 'Alpha Vantage') {
                    if (!apiKey) throw new Error('Alpha Vantage API key required');
                    df = await fetchAlphaVantageData(ticker, interval, apiKey);
                } else {
                    df = await fetchYahooFinanceData(ticker, interval, periodDays);
                }
                
                if (!df || df.length < 200) {
                    throw new Error('Insufficient data for backtesting (need at least 200 periods)');
                }
                
                // Calculate SMAs
                const sma20_vals = sma(df.map(d => d.close), 20);
                const sma200_vals = sma(df.map(d => d.close), 200);
                
                let capital = initialCapital;
                let shares = 0;
                let position = null; // 'long' or null
                const trades = [];
                
                // Detect crosses
                const goldenCrosses = [];
                const deathCrosses = [];
                for (let i = 200; i < df.length; i++) {
                    if (i === 0 || isNaN(sma20_vals[i]) || isNaN(sma200_vals[i]) || isNaN(sma20_vals[i-1]) || isNaN(sma200_vals[i-1])) continue;
                    
                    const prev_sma20 = sma20_vals[i-1];
                    const prev_sma200 = sma200_vals[i-1];
                    const curr_sma20 = sma20_vals[i];
                    const curr_sma200 = sma200_vals[i];
                    
                    if (prev_sma20 <= prev_sma200 && curr_sma20 > curr_sma200) {
                        goldenCrosses.push(i);
                    } else if (prev_sma20 >= prev_sma200 && curr_sma20 < curr_sma200) {
                        deathCrosses.push(i);
                    }
                }
                
                if (strategy === 'golden_death') {
                    for (let i = 200; i < df.length; i++) {
                        const price = df[i].close;
                        const date = df[i].timestamp || df[i].date || new Date();
                        
                        if (goldenCrosses.includes(i) && position === null) {
                            // Buy
                            shares = capital / price;
                            capital = 0;
                            position = 'long';
                            trades.push({ date, type: 'BUY', price, shares, capital: 0 });
                        } else if (deathCrosses.includes(i) && position === 'long') {
                            // Sell
                            capital = shares * price;
                            shares = 0;
                            position = null;
                            trades.push({ date, type: 'SELL', price, shares: 0, capital });
                        }
                    }
                } else if (strategy === 'buy_hold') {
                    const firstPrice = df[200].close;
                    shares = capital / firstPrice;
                    capital = 0;
                    position = 'long';
                    trades.push({ date: df[200].timestamp || df[200].date, type: 'BUY', price: firstPrice, shares, capital: 0 });
                }
                
                // Final value
                let finalCapital = capital;
                if (position === 'long' && shares > 0) {
                    finalCapital = shares * df[df.length - 1].close;
                }
                
                const totalReturn = ((finalCapital - initialCapital) / initialCapital) * 100;
                
                // Calculate equity curve for drawdown
                const equityCurve = [];
                let currentCapital = initialCapital;
                let currentShares = 0;
                let currentPosition = null;
                
                if (strategy === 'golden_death') {
                    for (let i = 200; i < df.length; i++) {
                        if (goldenCrosses.includes(i) && currentPosition === null) {
                            currentShares = currentCapital / df[i].close;
                            currentCapital = 0;
                            currentPosition = 'long';
                        } else if (deathCrosses.includes(i) && currentPosition === 'long') {
                            currentCapital = currentShares * df[i].close;
                            currentShares = 0;
                            currentPosition = null;
                        }
                        
                        if (currentPosition === 'long') {
                            equityCurve.push(currentShares * df[i].close);
                        } else {
                            equityCurve.push(currentCapital);
                        }
                    }
                } else {
                    const bhShares = initialCapital / df[200].close;
                    for (let i = 200; i < df.length; i++) {
                        equityCurve.push(bhShares * df[i].close);
                    }
                }
                
                // Calculate max drawdown
                let maxEquity = equityCurve[0];
                let maxDrawdown = 0;
                for (const equity of equityCurve) {
                    if (equity > maxEquity) maxEquity = equity;
                    const dd = ((equity - maxEquity) / maxEquity) * 100;
                    if (dd < maxDrawdown) maxDrawdown = dd;
                }
                
                let resultsHtml = `
                    <h3>Backtest Results</h3>
                    <div class="metrics" style="margin: 20px 0;">
                        <div class="metric">
                            <div class="metric-label">Initial Capital</div>
                            <div class="metric-value">$${initialCapital.toLocaleString()}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Final Capital</div>
                            <div class="metric-value">$${finalCapital.toFixed(2)}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Total Return</div>
                            <div class="metric-value" style="color: ${totalReturn >= 0 ? '#00ff88' : '#f31260'};">
                                ${totalReturn >= 0 ? '+' : ''}${totalReturn.toFixed(2)}%
                            </div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Max Drawdown</div>
                            <div class="metric-value" style="color: #f31260;">${maxDrawdown.toFixed(2)}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Number of Trades</div>
                            <div class="metric-value">${trades.length}</div>
                        </div>
                    </div>
                `;
                
                if (trades.length > 0) {
                    resultsHtml += `
                        <h3>Trade History</h3>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                            <thead>
                                <tr style="border-bottom: 2px solid #00d4ff;">
                                    <th style="padding: 10px; text-align: left;">Date</th>
                                    <th style="padding: 10px; text-align: left;">Type</th>
                                    <th style="padding: 10px; text-align: right;">Price</th>
                                    <th style="padding: 10px; text-align: right;">Shares</th>
                                    <th style="padding: 10px; text-align: right;">Capital</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    
                    trades.forEach(trade => {
                        const dateStr = trade.date instanceof Date ? trade.date.toISOString().split('T')[0] : 
                                       (typeof trade.date === 'string' ? trade.date.split('T')[0] : 'N/A');
                        resultsHtml += `
                            <tr style="border-bottom: 1px solid rgba(0,212,255,0.2);">
                                <td style="padding: 10px;">${dateStr}</td>
                                <td style="padding: 10px; color: ${trade.type === 'BUY' ? '#00ff88' : '#f31260'};">
                                    ${trade.type}
                                </td>
                                <td style="padding: 10px; text-align: right;">$${trade.price.toFixed(2)}</td>
                                <td style="padding: 10px; text-align: right;">${trade.shares > 0 ? trade.shares.toFixed(4) : 'N/A'}</td>
                                <td style="padding: 10px; text-align: right;">$${trade.capital > 0 ? trade.capital.toFixed(2) : 'N/A'}</td>
                            </tr>
                        `;
                    });
                    
                    resultsHtml += '</tbody></table>';
                }
                
                document.getElementById('backtestResults').innerHTML = resultsHtml;
                
            } catch (error) {
                document.getElementById('backtestResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Continue with remaining tabs (News, Patterns, Correlation, Journal, Signals, Risk)
        // These will be added in the next update due to length constraints

        // Render News Tab (simplified - full implementation would require news API)
        function renderNewsTab() {
            let html = `
                <h2>üì∞ News & Sentiment</h2>
                <p>View latest news articles and sentiment analysis for a ticker.</p>
                <p style="color: #888; font-size: 14px;">Note: Full news integration requires a news API. This is a placeholder for the feature.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Select Ticker:</label>
                        <input type="text" id="newsTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                </div>
                <button onclick="fetchNews()" class="sidebar button">Fetch News</button>
                
                <div id="newsResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        // Sentiment analysis helper
        function analyzeSentiment(text) {
            if (!text || text.trim().length === 0) {
                return { sentiment: 'NEUTRAL', score: 0.0, confidence: 0.0, bullish_keywords: 0, bearish_keywords: 0 };
            }
            
            const textLower = text.toLowerCase();
            
            const bullishKeywords = [
                'surge', 'rally', 'gain', 'rise', 'up', 'bullish', 'buy', 'strong', 'growth',
                'profit', 'beat', 'exceed', 'outperform', 'positive', 'optimistic', 'upgrade',
                'breakthrough', 'success', 'win', 'soar', 'jump', 'climb', 'advance', 'boom'
            ];
            
            const bearishKeywords = [
                'drop', 'fall', 'decline', 'down', 'bearish', 'sell', 'weak', 'loss', 'miss',
                'disappoint', 'underperform', 'negative', 'pessimistic', 'downgrade', 'crash',
                'plunge', 'tumble', 'slump', 'sink', 'retreat', 'worry', 'concern', 'risk',
                'warning', 'crisis', 'recession', 'bankruptcy', 'lawsuit', 'investigation'
            ];
            
            let bullishCount = 0;
            let bearishCount = 0;
            
            bullishKeywords.forEach(word => {
                if (textLower.includes(word)) bullishCount++;
            });
            
            bearishKeywords.forEach(word => {
                if (textLower.includes(word)) bearishCount++;
            });
            
            const totalKeywords = bullishCount + bearishCount;
            let score = 0.0;
            if (totalKeywords > 0) {
                score = (bullishCount - bearishCount) / totalKeywords;
            }
            
            let sentiment = 'NEUTRAL';
            let confidence = 0.0;
            
            if (score > 0.2) {
                sentiment = 'BULLISH';
                confidence = Math.min(Math.abs(score) * 2, 1.0);
            } else if (score < -0.2) {
                sentiment = 'BEARISH';
                confidence = Math.min(Math.abs(score) * 2, 1.0);
            } else {
                sentiment = 'NEUTRAL';
                confidence = 1.0 - Math.abs(score);
            }
            
            return {
                sentiment,
                score: score.toFixed(3),
                confidence: confidence.toFixed(2),
                bullish_keywords: bullishCount,
                bearish_keywords: bearishCount
            };
        }

        async function fetchNews() {
            const ticker = document.getElementById('newsTicker').value.trim().toUpperCase() || currentTicker;
            
            document.getElementById('newsResults').innerHTML = '<div class="loading">Fetching news...</div>';
            
            try {
                // Try to fetch news via Yahoo Finance API with CORS proxy
                const proxies = [
                    'https://api.allorigins.win/get?url=',
                    'https://corsproxy.io/?',
                    'https://thingproxy.freeboard.io/fetch/'
                ];
                
                const yahooNewsUrl = encodeURIComponent(`https://query1.finance.yahoo.com/v1/finance/search?q=${ticker}&newsCount=10`);
                
                let newsData = null;
                let lastError = null;
                
                for (let i = 0; i < proxies.length; i++) {
                    try {
                        const proxyUrl = proxies[i] + yahooNewsUrl;
                        const response = await fetch(proxyUrl);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        
                        let data = await response.json();
                        
                        // Handle different proxy response formats
                        if (data.contents) {
                            try {
                                data = JSON.parse(data.contents);
                            } catch (e) {
                                // Not JSON, skip
                            }
                        }
                        
                        if (data.news && Array.isArray(data.news) && data.news.length > 0) {
                            newsData = data.news;
                            break;
                        }
                        
                        // Try alternative structure
                        if (data.quotes && data.quotes.length > 0) {
                            // This might be a different response format, skip for now
                        }
                        
                    } catch (error) {
                        lastError = error;
                        continue;
                    }
                }
                
                if (!newsData || newsData.length === 0) {
                    // Fallback: Show placeholder with sentiment analysis on ticker name
                    const sentiment = analyzeSentiment(ticker);
                    
                    document.getElementById('newsResults').innerHTML = `
                        <div class="info-box">
                            <h3>üì∞ News for ${ticker}</h3>
                            <p>News API integration is limited due to CORS restrictions.</p>
                            <p>For full news functionality, you can:</p>
                            <ul style="margin-left: 20px; margin-top: 10px;">
                                <li>Use the Streamlit app version (app.py) which has full news integration</li>
                                <li>Integrate with a news API service (NewsAPI, Alpha Vantage News, etc.)</li>
                                <li>Set up a backend server to proxy news requests</li>
                            </ul>
                            <p style="margin-top: 15px;">The HTML version includes all other features from the full app, but news requires backend services due to CORS limitations.</p>
                        </div>
                    `;
                    return;
                }
                
                // Process and display news
                const enrichedNews = newsData.slice(0, 10).map(item => {
                    const title = item.title || item.headline || 'Article';
                    const publisher = item.publisher || item.source || 'Unknown';
                    const summary = item.summary || item.description || '';
                    const link = item.link || item.url || '';
                    const pubTime = item.providerPublishTime || item.pubDate || new Date().toISOString();
                    
                    const textForSentiment = title + ' ' + summary;
                    const sentiment = analyzeSentiment(textForSentiment);
                    
                    return {
                        title,
                        publisher,
                        summary,
                        link,
                        pubTime,
                        sentiment
                    };
                });
                
                // Calculate overall sentiment
                const bullishCount = enrichedNews.filter(n => n.sentiment.sentiment === 'BULLISH').length;
                const bearishCount = enrichedNews.filter(n => n.sentiment.sentiment === 'BEARISH').length;
                const neutralCount = enrichedNews.length - bullishCount - bearishCount;
                
                let overallSentiment = '‚ö™ NEUTRAL';
                let overallColor = '#b0b0b0';
                if (bullishCount > bearishCount && bullishCount > neutralCount) {
                    overallSentiment = 'üü¢ BULLISH';
                    overallColor = '#00ff88';
                } else if (bearishCount > bullishCount && bearishCount > neutralCount) {
                    overallSentiment = 'üî¥ BEARISH';
                    overallColor = '#f31260';
                }
                
                let html = `
                    <h3>üìä Overall News Sentiment for ${ticker}</h3>
                    <div class="metrics" style="margin: 20px 0;">
                        <div class="metric">
                            <div class="metric-label">Overall Sentiment</div>
                            <div class="metric-value" style="color: ${overallColor}; font-size: 24px;">${overallSentiment}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Total Articles</div>
                            <div class="metric-value">${enrichedNews.length}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">üü¢ Bullish</div>
                            <div class="metric-value">${bullishCount}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">üî¥ Bearish</div>
                            <div class="metric-value">${bearishCount}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">‚ö™ Neutral</div>
                            <div class="metric-value">${neutralCount}</div>
                        </div>
                    </div>
                    
                    <h3 style="margin-top: 30px;">News Articles</h3>
                `;
                
                // Sort by sentiment (bullish first, then bearish, then neutral)
                const sentimentOrder = { 'BULLISH': 0, 'BEARISH': 1, 'NEUTRAL': 2 };
                enrichedNews.sort((a, b) => {
                    const orderA = sentimentOrder[a.sentiment.sentiment] || 2;
                    const orderB = sentimentOrder[b.sentiment.sentiment] || 2;
                    if (orderA !== orderB) return orderA - orderB;
                    return parseFloat(b.sentiment.confidence) - parseFloat(a.sentiment.confidence);
                });
                
                enrichedNews.forEach((item, idx) => {
                    const sentimentEmoji = item.sentiment.sentiment === 'BULLISH' ? 'üü¢' : 
                                          (item.sentiment.sentiment === 'BEARISH' ? 'üî¥' : '‚ö™');
                    const sentimentColor = item.sentiment.sentiment === 'BULLISH' ? '#00ff88' :
                                          (item.sentiment.sentiment === 'BEARISH' ? '#f31260' : '#b0b0b0');
                    
                    const pubDate = new Date(item.pubTime * 1000 || item.pubTime).toLocaleString();
                    
                    html += `
                        <div class="info-box" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <h4 style="color: ${sentimentColor}; margin: 0;">
                                    ${sentimentEmoji} ${item.title}
                                </h4>
                                ${item.link ? `<a href="${item.link}" target="_blank" style="color: #00d4ff; text-decoration: none;">üîó Read</a>` : ''}
                            </div>
                            <p style="color: #b0b0b0; font-size: 12px; margin: 5px 0;">
                                <strong>Publisher:</strong> ${item.publisher} | 
                                <strong>Published:</strong> ${pubDate} |
                                <strong>Sentiment:</strong> <span style="color: ${sentimentColor};">${item.sentiment.sentiment}</span> 
                                (Confidence: ${(parseFloat(item.sentiment.confidence) * 100).toFixed(0)}%)
                            </p>
                            ${item.summary ? `<p style="color: #b0b0b0; margin-top: 10px; font-size: 14px;">${item.summary}</p>` : ''}
                        </div>
                    `;
                });
                
                document.getElementById('newsResults').innerHTML = html;
                
            } catch (error) {
                document.getElementById('newsResults').innerHTML = 
                    `<div class="error">Error fetching news: ${error.message}<br><br>
                    Note: News feature is limited in the HTML version due to CORS restrictions. 
                    The full Streamlit app (app.py) has complete news integration.</div>`;
            }
        }

        // Render Patterns Tab
        function renderPatternsTab() {
            let html = `
                <h2>üìê Chart Pattern Detection</h2>
                <p>Detect common chart patterns like Double Top/Bottom, Head & Shoulders, etc.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Select Ticker:</label>
                        <input type="text" id="patternTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                </div>
                <button onclick="analyzePatterns()" class="sidebar button">Analyze Patterns</button>
                
                <div id="patternResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        async function analyzePatterns() {
            const ticker = document.getElementById('patternTicker').value.trim().toUpperCase() || currentTicker;
            
            document.getElementById('patternResults').innerHTML = '<div class="loading">Analyzing patterns...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                const apiKey = document.getElementById('apiKey').value;
                
                let df;
                if (dataSource === 'Alpha Vantage') {
                    if (!apiKey) throw new Error('Alpha Vantage API key required');
                    df = await fetchAlphaVantageData(ticker, interval, apiKey);
                } else {
                    df = await fetchYahooFinanceData(ticker, interval, periodDays);
                }
                
                if (!df || df.length < 30) {
                    throw new Error('Insufficient data for pattern detection (need at least 30 periods)');
                }
                
                // Simplified pattern detection (full implementation would be more complex)
                const patterns = [];
                const highs = df.map(d => d.high);
                const lows = df.map(d => d.low);
                const closes = df.map(d => d.close);
                
                // Simple Double Top/Bottom detection
                const recent = df.slice(-60);
                const recentHighs = recent.map(d => d.high);
                const recentLows = recent.map(d => d.low);
                
                // Find local peaks and troughs
                const peaks = [];
                const troughs = [];
                for (let i = 5; i < recentHighs.length - 5; i++) {
                    let isPeak = true;
                    let isTrough = true;
                    for (let j = -5; j <= 5; j++) {
                        if (j === 0) continue;
                        if (recentHighs[i] <= recentHighs[i+j]) isPeak = false;
                        if (recentLows[i] >= recentLows[i+j]) isTrough = false;
                    }
                    if (isPeak) peaks.push(i + (df.length - recent.length));
                    if (isTrough) troughs.push(i + (df.length - recent.length));
                }
                
                // Double Top
                if (peaks.length >= 2) {
                    const peak1 = df[peaks[peaks.length - 2]];
                    const peak2 = df[peaks[peaks.length - 1]];
                    if (Math.abs(peak1.high - peak2.high) / Math.max(peak1.high, peak2.high) < 0.03) {
                        patterns.push({
                            type: 'Double Top',
                            confidence: 0.7,
                            description: `Bearish reversal pattern: Two similar peaks at $${peak1.high.toFixed(2)} and $${peak2.high.toFixed(2)}`
                        });
                    }
                }
                
                // Double Bottom
                if (troughs.length >= 2) {
                    const trough1 = df[troughs[troughs.length - 2]];
                    const trough2 = df[troughs[troughs.length - 1]];
                    if (Math.abs(trough1.low - trough2.low) / Math.max(trough1.low, trough2.low) < 0.03) {
                        patterns.push({
                            type: 'Double Bottom',
                            confidence: 0.7,
                            description: `Bullish reversal pattern: Two similar troughs at $${trough1.low.toFixed(2)} and $${trough2.low.toFixed(2)}`
                        });
                    }
                }
                
                // Trend detection
                if (df.length >= 20) {
                    const recentPrices = closes.slice(-20);
                    const priceTrend = ((recentPrices[recentPrices.length - 1] - recentPrices[0]) / recentPrices[0]) * 100;
                    
                    if (priceTrend > 5) {
                        patterns.push({
                            type: 'Uptrend',
                            confidence: 0.5,
                            description: `Strong upward trend: ${priceTrend.toFixed(1)}% gain in last 20 periods`
                        });
                    } else if (priceTrend < -5) {
                        patterns.push({
                            type: 'Downtrend',
                            confidence: 0.5,
                            description: `Strong downward trend: ${priceTrend.toFixed(1)}% decline in last 20 periods`
                        });
                    } else {
                        patterns.push({
                            type: 'Sideways/Consolidation',
                            confidence: 0.4,
                            description: 'Price moving in a range, no clear trend'
                        });
                    }
                }
                
                if (patterns.length === 0) {
                    document.getElementById('patternResults').innerHTML = 
                        `<div class="info-box">No patterns detected for ${ticker}</div>`;
                    return;
                }
                
                let resultsHtml = `<h3>Detected Patterns for ${ticker}</h3>`;
                
                patterns.forEach(pattern => {
                    const isBullish = ['Double Bottom', 'Uptrend'].includes(pattern.type);
                    const isBearish = ['Double Top', 'Downtrend'].includes(pattern.type);
                    const emoji = isBullish ? 'üü¢' : (isBearish ? 'üî¥' : '‚ö™');
                    const color = isBullish ? '#00ff88' : (isBearish ? '#f31260' : '#b0b0b0');
                    
                    resultsHtml += `
                        <div class="info-box" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div>
                                    <h4 style="color: ${color}; margin-bottom: 5px;">
                                        ${emoji} ${pattern.type}
                                    </h4>
                                    <p style="color: #b0b0b0; font-size: 14px;">${pattern.description}</p>
                                </div>
                                <div class="metric" style="margin: 0; padding: 10px 15px; min-width: 100px;">
                                    <div class="metric-label">Confidence</div>
                                    <div class="metric-value" style="font-size: 18px;">${(pattern.confidence * 100).toFixed(0)}%</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                document.getElementById('patternResults').innerHTML = resultsHtml;
                
            } catch (error) {
                document.getElementById('patternResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Render Correlation Tab
        function renderCorrelationTab() {
            let html = `
                <h2>üîó Correlation Analysis</h2>
                <p>Analyze correlation between multiple tickers.</p>
                
                <div style="margin-bottom: 20px;">
                    <label>Enter Tickers (comma-separated, minimum 2):</label>
                    <input type="text" id="correlationTickers" placeholder="e.g., SPY,AAPL,MSFT,TSLA" value="${currentTicker}" style="width: 100%; margin-top: 8px;">
                </div>
                <button onclick="calculateCorrelation()" class="sidebar button">Calculate Correlation</button>
                
                <div id="correlationResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        async function calculateCorrelation() {
            const tickerInput = document.getElementById('correlationTickers').value.trim();
            const tickers = tickerInput ? tickerInput.split(',').map(t => t.trim().toUpperCase()).filter(t => t) : [];
            
            if (tickers.length < 2) {
                alert('Please enter at least 2 tickers');
                return;
            }
            
            document.getElementById('correlationResults').innerHTML = '<div class="loading">Calculating correlation matrix...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                const apiKey = document.getElementById('apiKey').value;
                
                // Fetch data for all tickers
                const prices = {};
                for (const ticker of tickers) {
                    let df;
                    if (dataSource === 'Alpha Vantage') {
                        if (!apiKey) throw new Error('Alpha Vantage API key required');
                        df = await fetchAlphaVantageData(ticker, interval, apiKey);
                    } else {
                        df = await fetchYahooFinanceData(ticker, interval, periodDays);
                    }
                    
                    if (df && df.length > 0) {
                        prices[ticker] = df.map(d => d.close);
                    }
                }
                
                if (Object.keys(prices).length < 2) {
                    throw new Error('Need at least 2 tickers with valid data');
                }
                
                // Align prices by date and calculate returns
                const alignedPrices = {};
                const minLength = Math.min(...Object.values(prices).map(p => p.length));
                
                Object.keys(prices).forEach(ticker => {
                    alignedPrices[ticker] = prices[ticker].slice(-minLength);
                });
                
                // Calculate returns
                const returns = {};
                Object.keys(alignedPrices).forEach(ticker => {
                    returns[ticker] = [];
                    for (let i = 1; i < alignedPrices[ticker].length; i++) {
                        const ret = (alignedPrices[ticker][i] - alignedPrices[ticker][i-1]) / alignedPrices[ticker][i-1];
                        returns[ticker].push(ret);
                    }
                });
                
                // Calculate correlation matrix
                const correlationMatrix = {};
                const tickerList = Object.keys(returns);
                
                tickerList.forEach(ticker1 => {
                    correlationMatrix[ticker1] = {};
                    tickerList.forEach(ticker2 => {
                        if (ticker1 === ticker2) {
                            correlationMatrix[ticker1][ticker2] = 1.0;
                        } else {
                            const ret1 = returns[ticker1];
                            const ret2 = returns[ticker2];
                            
                            const mean1 = ret1.reduce((a, b) => a + b, 0) / ret1.length;
                            const mean2 = ret2.reduce((a, b) => a + b, 0) / ret2.length;
                            
                            let numerator = 0;
                            let sumSq1 = 0;
                            let sumSq2 = 0;
                            
                            for (let i = 0; i < ret1.length; i++) {
                                const diff1 = ret1[i] - mean1;
                                const diff2 = ret2[i] - mean2;
                                numerator += diff1 * diff2;
                                sumSq1 += diff1 * diff1;
                                sumSq2 += diff2 * diff2;
                            }
                            
                            const denominator = Math.sqrt(sumSq1 * sumSq2);
                            correlationMatrix[ticker1][ticker2] = denominator === 0 ? 0 : numerator / denominator;
                        }
                    });
                });
                
                // Create correlation heatmap using Plotly
                const z = tickerList.map(t1 => tickerList.map(t2 => correlationMatrix[t1][t2]));
                
                const trace = {
                    z: z,
                    x: tickerList,
                    y: tickerList,
                    type: 'heatmap',
                    colorscale: 'RdBu',
                    zmid: 0,
                    text: z.map(row => row.map(val => val.toFixed(3))),
                    texttemplate: '%{text}',
                    textfont: { size: 10 },
                    colorbar: { title: 'Correlation' }
                };
                
                const layout = {
                    title: 'Correlation Matrix',
                    plot_bgcolor: '#000000',
                    paper_bgcolor: '#000000',
                    font: { color: '#e8ecf3' },
                    width: 800,
                    height: 600
                };
                
                Plotly.newPlot('correlationResults', [trace], layout);
                
                // Also create table
                let tableHtml = `
                    <h3 style="margin-top: 30px;">Correlation Data</h3>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #00d4ff;">
                                <th style="padding: 10px; text-align: left;"></th>
                `;
                
                tickerList.forEach(ticker => {
                    tableHtml += `<th style="padding: 10px; text-align: right;">${ticker}</th>`;
                });
                
                tableHtml += '</tr></thead><tbody>';
                
                tickerList.forEach(ticker1 => {
                    tableHtml += `<tr style="border-bottom: 1px solid rgba(0,212,255,0.2);"><td style="padding: 10px; font-weight: bold;">${ticker1}</td>`;
                    tickerList.forEach(ticker2 => {
                        const corr = correlationMatrix[ticker1][ticker2];
                        const color = corr > 0.5 ? '#00ff88' : (corr < -0.5 ? '#f31260' : '#b0b0b0');
                        tableHtml += `<td style="padding: 10px; text-align: right; color: ${color};">
                            ${corr.toFixed(3)}
                        </td>`;
                    });
                    tableHtml += '</tr>';
                });
                
                tableHtml += '</tbody></table>';
                
                document.getElementById('correlationResults').innerHTML = '<div id="correlationChart" style="margin-bottom: 30px;"></div>' + tableHtml;
                
                // Render heatmap in the chart div
                Plotly.newPlot('correlationChart', [trace], layout);
                
            } catch (error) {
                document.getElementById('correlationResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Render Journal Tab
        function renderJournalTab() {
            const journal = loadJournal();
            
            let html = `
                <h2>üìù Trade Journal</h2>
                <p>Log your trades and track performance.</p>
                
                <h3>Add New Trade</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label>Ticker:</label>
                        <input type="text" id="journalTicker" placeholder="e.g., SPY" style="width: 100%;">
                    </div>
                    <div>
                        <label>Type:</label>
                        <select id="journalType" style="width: 100%;">
                            <option value="Buy">Buy</option>
                            <option value="Sell">Sell</option>
                        </select>
                    </div>
                    <div>
                        <label>Price ($):</label>
                        <input type="number" id="journalPrice" step="0.01" min="0" style="width: 100%;">
                    </div>
                    <div>
                        <label>Shares:</label>
                        <input type="number" id="journalShares" step="0.01" min="0" style="width: 100%;">
                    </div>
                    <div>
                        <label>Date:</label>
                        <input type="date" id="journalDate" value="${new Date().toISOString().split('T')[0]}" style="width: 100%;">
                    </div>
                    <div>
                        <label>Notes:</label>
                        <input type="text" id="journalNotes" placeholder="Optional notes" style="width: 100%;">
                    </div>
                </div>
                <button onclick="addJournalEntry()" class="sidebar button">Add Trade</button>
                
                <hr style="margin: 30px 0; border-color: rgba(0,212,255,0.3);">
                <h3>Trade History</h3>
            `;
            
            if (journal.length > 0) {
                // Sort by date descending
                const sortedJournal = [...journal].sort((a, b) => new Date(b.date) - new Date(a.date));
                
                html += `
                    <div style="margin-bottom: 15px;">
                        <label>
                            <input type="checkbox" id="calcPnL" onchange="renderJournalTab()">
                            Calculate P&L with current prices
                        </label>
                    </div>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <thead>
                            <tr style="border-bottom: 2px solid #00d4ff;">
                                <th style="padding: 10px; text-align: left;">Date</th>
                                <th style="padding: 10px; text-align: left;">Ticker</th>
                                <th style="padding: 10px; text-align: left;">Type</th>
                                <th style="padding: 10px; text-align: right;">Price</th>
                                <th style="padding: 10px; text-align: right;">Shares</th>
                                <th id="pnlHeader" style="padding: 10px; text-align: right; display: none;">Current Price</th>
                                <th id="pnlHeader2" style="padding: 10px; text-align: right; display: none;">P&L</th>
                                <th id="pnlHeader3" style="padding: 10px; text-align: right; display: none;">P&L %</th>
                                <th style="padding: 10px; text-align: left;">Notes</th>
                                <th style="padding: 10px; text-align: center;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                sortedJournal.forEach((trade, i) => {
                    html += `
                        <tr style="border-bottom: 1px solid rgba(0,212,255,0.2);">
                            <td style="padding: 10px;">${trade.date}</td>
                            <td style="padding: 10px;">${trade.ticker}</td>
                            <td style="padding: 10px; color: ${trade.type === 'Buy' ? '#00ff88' : '#f31260'};">
                                ${trade.type}
                            </td>
                            <td style="padding: 10px; text-align: right;">$${trade.price.toFixed(2)}</td>
                            <td style="padding: 10px; text-align: right;">${trade.shares.toFixed(2)}</td>
                            <td id="pnlCell${i}" style="padding: 10px; text-align: right; display: none;"></td>
                            <td id="pnlCell2${i}" style="padding: 10px; text-align: right; display: none;"></td>
                            <td id="pnlCell3${i}" style="padding: 10px; text-align: right; display: none;"></td>
                            <td style="padding: 10px;">${trade.notes || ''}</td>
                            <td style="padding: 10px; text-align: center;">
                                <button onclick="deleteJournalEntry(${i})" class="sidebar button" style="width: auto; padding: 5px 15px; background: linear-gradient(90deg, #f31260 0%, #cc0d4d 100%);">Delete</button>
                            </td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                
                // Summary
                const buyTrades = journal.filter(t => t.type === 'Buy').length;
                const sellTrades = journal.filter(t => t.type === 'Sell').length;
                
                html += `
                    <h3 style="margin-top: 30px;">Summary</h3>
                    <div class="metrics" style="margin: 20px 0;">
                        <div class="metric">
                            <div class="metric-label">Total Trades</div>
                            <div class="metric-value">${journal.length}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Buy Trades</div>
                            <div class="metric-value">${buyTrades}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Sell Trades</div>
                            <div class="metric-value">${sellTrades}</div>
                        </div>
                    </div>
                `;
            } else {
                html += '<div class="info-box">No trades logged yet. Add your first trade above.</div>';
            }
            
            document.getElementById('tabContent').innerHTML = html;
            
            // Calculate P&L if checkbox is checked
            const calcPnL = document.getElementById('calcPnL');
            if (calcPnL && calcPnL.checked && journal.length > 0) {
                calculateJournalPnL(journal);
            }
        }

        function loadJournal() {
            const saved = localStorage.getItem('traderqJournal');
            return saved ? JSON.parse(saved) : [];
        }

        function saveJournal(journal) {
            localStorage.setItem('traderqJournal', JSON.stringify(journal));
        }

        function addJournalEntry() {
            const ticker = document.getElementById('journalTicker').value.trim().toUpperCase();
            const type = document.getElementById('journalType').value;
            const price = parseFloat(document.getElementById('journalPrice').value);
            const shares = parseFloat(document.getElementById('journalShares').value);
            const date = document.getElementById('journalDate').value;
            const notes = document.getElementById('journalNotes').value.trim();
            
            if (!ticker || !price || !shares || !date) {
                alert('Please fill in all required fields');
                return;
            }
            
            const journal = loadJournal();
            journal.push({
                ticker,
                type,
                price,
                shares,
                date,
                notes,
                timestamp: new Date().toISOString()
            });
            
            saveJournal(journal);
            renderJournalTab();
        }

        function deleteJournalEntry(index) {
            const journal = loadJournal();
            const sortedJournal = [...journal].sort((a, b) => new Date(b.date) - new Date(a.date));
            const tradeToDelete = sortedJournal[index];
            const originalIndex = journal.findIndex(t => t.timestamp === tradeToDelete.timestamp);
            
            if (originalIndex !== -1) {
                journal.splice(originalIndex, 1);
                saveJournal(journal);
                renderJournalTab();
            }
        }

        async function calculateJournalPnL(journal) {
            const calcPnL = document.getElementById('calcPnL');
            if (!calcPnL || !calcPnL.checked) return;
            
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const dataSource = document.getElementById('dataSource').value;
            const interval = document.getElementById('timeframe').value;
            const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
            const apiKey = document.getElementById('apiKey').value;
            
            const sortedJournal = [...journal].sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Show headers
            document.getElementById('pnlHeader').style.display = 'table-cell';
            document.getElementById('pnlHeader2').style.display = 'table-cell';
            document.getElementById('pnlHeader3').style.display = 'table-cell';
            
            for (let i = 0; i < sortedJournal.length; i++) {
                const trade = sortedJournal[i];
                
                try {
                    let df;
                    if (dataSource === 'Alpha Vantage') {
                        if (!apiKey) continue;
                        df = await fetchAlphaVantageData(trade.ticker, interval, apiKey);
                    } else {
                        df = await fetchYahooFinanceData(trade.ticker, interval, periodDays);
                    }
                    
                    if (df && df.length > 0) {
                        const currentPrice = df[df.length - 1].close;
                        let pnl, pnlPct;
                        
                        if (trade.type === 'Buy') {
                            pnl = (currentPrice - trade.price) * trade.shares;
                            pnlPct = ((currentPrice - trade.price) / trade.price) * 100;
                        } else {
                            pnl = (trade.price - currentPrice) * trade.shares;
                            pnlPct = ((trade.price - currentPrice) / currentPrice) * 100;
                        }
                        
                        document.getElementById(`pnlCell${i}`).style.display = 'table-cell';
                        document.getElementById(`pnlCell${i}`).textContent = `$${currentPrice.toFixed(2)}`;
                        document.getElementById(`pnlCell2${i}`).style.display = 'table-cell';
                        document.getElementById(`pnlCell2${i}`).textContent = `$${pnl.toFixed(2)}`;
                        document.getElementById(`pnlCell2${i}`).style.color = pnl >= 0 ? '#00ff88' : '#f31260';
                        document.getElementById(`pnlCell3${i}`).style.display = 'table-cell';
                        document.getElementById(`pnlCell3${i}`).textContent = `${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%`;
                        document.getElementById(`pnlCell3${i}`).style.color = pnlPct >= 0 ? '#00ff88' : '#f31260';
                    }
                } catch (error) {
                    // Skip if data fetch fails
                }
            }
        }

        // Render Signals Tab
        function renderSignalsTab() {
            let html = `
                <h2>‚ö° Trading Signal Generator</h2>
                <p>Get AI-powered buy/sell signals by combining multiple indicators.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Select Ticker:</label>
                        <input type="text" id="signalTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                </div>
                <button onclick="generateSignal()" class="sidebar button">Generate Signal</button>
                
                <div id="signalResults" style="margin-top: 30px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        async function generateSignal() {
            const ticker = document.getElementById('signalTicker').value.trim().toUpperCase() || currentTicker;
            
            document.getElementById('signalResults').innerHTML = '<div class="loading">Generating trading signal...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                const apiKey = document.getElementById('apiKey').value;
                
                let df;
                if (dataSource === 'Alpha Vantage') {
                    if (!apiKey) throw new Error('Alpha Vantage API key required');
                    df = await fetchAlphaVantageData(ticker, interval, apiKey);
                } else {
                    df = await fetchYahooFinanceData(ticker, interval, periodDays);
                }
                
                if (!df || df.length < 200) {
                    throw new Error('Insufficient data for signal generation');
                }
                
                // Use the existing AI recommendation function logic
                if (!currentData || currentData.length === 0) {
                    currentData = df;
                    currentTicker = ticker;
                }
                
                // Trigger AI recommendation which will display in AI tab
                generateAIRecommendation();
                
                // Switch to AI Recommendations tab to show results
                setTimeout(() => {
                    switchTab(11);
                }, 100);
                
            } catch (error) {
                document.getElementById('signalResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Render Risk Tab
        function renderRiskTab() {
            let html = `
                <h2>üõ°Ô∏è Risk Management Dashboard</h2>
                <p>Calculate position sizes, stop-losses, and risk/reward ratios.</p>
                
                <h3>Position Size Calculator</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Symbol:</label>
                        <input type="text" id="riskTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                    <div>
                        <label>Account Size ($):</label>
                        <input type="number" id="accountSize" value="10000" min="0" step="1000" style="width: 100%;">
                    </div>
                    <div>
                        <label>Risk Per Trade (%):</label>
                        <input type="number" id="riskPercent" value="2" min="0.1" max="10" step="0.1" style="width: 100%;">
                    </div>
                    <div>
                        <label>Entry Price ($):</label>
                        <input type="number" id="entryPrice" step="0.01" min="0" style="width: 100%;">
                    </div>
                    <div>
                        <label>Stop Loss ($):</label>
                        <input type="number" id="stopLossPrice" step="0.01" min="0" style="width: 100%;">
                    </div>
                </div>
                <button onclick="calculatePositionSize()" class="sidebar button">Calculate Position Size</button>
                <div id="positionSizeResults" style="margin-top: 20px;"></div>
                
                <hr style="margin: 30px 0; border-color: rgba(0,212,255,0.3);">
                
                <h3>ATR-Based Stop Loss Calculator</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Select Ticker:</label>
                        <input type="text" id="atrTicker" placeholder="${currentTicker}" value="${currentTicker}" style="width: 100%;">
                    </div>
                    <div>
                        <label>ATR Multiplier:</label>
                        <input type="number" id="atrMultiplier" value="2" min="1" max="5" step="0.5" style="width: 100%;">
                    </div>
                    <div>
                        <label>Position Type:</label>
                        <select id="positionType" style="width: 100%;">
                            <option value="long">Long</option>
                            <option value="short">Short</option>
                        </select>
                    </div>
                </div>
                <button onclick="calculateATRStop()" class="sidebar button">Calculate ATR Stop Loss</button>
                <div id="atrResults" style="margin-top: 20px;"></div>
                
                <hr style="margin: 30px 0; border-color: rgba(0,212,255,0.3);">
                
                <h3>Risk/Reward Ratio Calculator</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label>Entry Price:</label>
                        <input type="number" id="rrEntry" step="0.01" min="0" style="width: 100%;">
                    </div>
                    <div>
                        <label>Stop Loss:</label>
                        <input type="number" id="rrStop" step="0.01" min="0" style="width: 100%;">
                    </div>
                    <div>
                        <label>Target Price:</label>
                        <input type="number" id="rrTarget" step="0.01" min="0" style="width: 100%;">
                    </div>
                </div>
                <button onclick="calculateRiskReward()" class="sidebar button">Calculate Risk/Reward</button>
                <div id="rrResults" style="margin-top: 20px;"></div>
            `;
            
            document.getElementById('tabContent').innerHTML = html;
        }

        function calculatePositionSize() {
            const accountSize = parseFloat(document.getElementById('accountSize').value) || 0;
            const riskPercent = parseFloat(document.getElementById('riskPercent').value) || 0;
            const entryPrice = parseFloat(document.getElementById('entryPrice').value) || 0;
            const stopLossPrice = parseFloat(document.getElementById('stopLossPrice').value) || 0;
            
            if (entryPrice <= 0 || stopLossPrice <= 0 || riskPercent <= 0) {
                document.getElementById('positionSizeResults').innerHTML = 
                    '<div class="error">Invalid inputs. Please check entry price and stop loss.</div>';
                return;
            }
            
            const riskPerShare = Math.abs(entryPrice - stopLossPrice);
            const dollarRisk = accountSize * (riskPercent / 100);
            const shares = dollarRisk / riskPerShare;
            const positionValue = shares * entryPrice;
            
            document.getElementById('positionSizeResults').innerHTML = `
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Shares to Buy</div>
                        <div class="metric-value">${shares.toFixed(2)}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Position Value</div>
                        <div class="metric-value">$${positionValue.toLocaleString()}</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Dollar Risk</div>
                        <div class="metric-value">$${dollarRisk.toFixed(2)}</div>
                    </div>
                </div>
                <div class="info-box" style="margin-top: 15px;">
                    üí° Risk per share: $${riskPerShare.toFixed(2)}
                </div>
            `;
        }

        async function calculateATRStop() {
            const ticker = document.getElementById('atrTicker').value.trim().toUpperCase() || currentTicker;
            const atrMultiplier = parseFloat(document.getElementById('atrMultiplier').value) || 2;
            const isLong = document.getElementById('positionType').value === 'long';
            
            document.getElementById('atrResults').innerHTML = '<div class="loading">Calculating ATR stop loss...</div>';
            
            try {
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const dataSource = document.getElementById('dataSource').value;
                const interval = document.getElementById('timeframe').value;
                const periodDays = parseInt(document.getElementById('periodDays').value) || 365;
                const apiKey = document.getElementById('apiKey').value;
                
                let df;
                if (dataSource === 'Alpha Vantage') {
                    if (!apiKey) throw new Error('Alpha Vantage API key required');
                    df = await fetchAlphaVantageData(ticker, interval, apiKey);
                } else {
                    df = await fetchYahooFinanceData(ticker, interval, periodDays);
                }
                
                if (!df || df.length < 14) {
                    throw new Error('Insufficient data for ATR calculation');
                }
                
                // Calculate ATR
                const atrValues = atr(
                    df.map(d => d.high),
                    df.map(d => d.low),
                    df.map(d => d.close),
                    14
                );
                
                const currentATR = atrValues[atrValues.length - 1];
                const currentPrice = df[df.length - 1].close;
                
                let atrStop;
                if (isLong) {
                    atrStop = currentPrice - (currentATR * atrMultiplier);
                } else {
                    atrStop = currentPrice + (currentATR * atrMultiplier);
                }
                
                const stopDistance = Math.abs(currentPrice - atrStop);
                const stopPct = (stopDistance / currentPrice) * 100;
                
                document.getElementById('atrResults').innerHTML = `
                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-label">Current Price</div>
                            <div class="metric-value">$${currentPrice.toFixed(2)}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">ATR Stop Loss</div>
                            <div class="metric-value">$${atrStop.toFixed(2)}</div>
                        </div>
                    </div>
                    <div class="info-box" style="margin-top: 15px;">
                        Stop loss is $${stopDistance.toFixed(2)} (${stopPct.toFixed(2)}%) away from current price
                    </div>
                `;
                
            } catch (error) {
                document.getElementById('atrResults').innerHTML = 
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        function calculateRiskReward() {
            const entry = parseFloat(document.getElementById('rrEntry').value) || 0;
            const stop = parseFloat(document.getElementById('rrStop').value) || 0;
            const target = parseFloat(document.getElementById('rrTarget').value) || 0;
            
            if (entry <= 0) {
                document.getElementById('rrResults').innerHTML = 
                    '<div class="error">Invalid inputs</div>';
                return;
            }
            
            const risk = Math.abs(entry - stop);
            const reward = Math.abs(target - entry);
            const riskPct = (risk / entry) * 100;
            const rewardPct = (reward / entry) * 100;
            const rrRatio = risk > 0 ? reward / risk : 0;
            
            let rrQuality = '';
            let rrColor = '#b0b0b0';
            if (rrRatio >= 3) {
                rrQuality = '‚úÖ Excellent';
                rrColor = '#00ff88';
            } else if (rrRatio >= 2) {
                rrQuality = '‚úÖ Good';
                rrColor = '#00ff88';
            } else if (rrRatio >= 1) {
                rrQuality = '‚ö†Ô∏è Acceptable';
                rrColor = '#ffc107';
            } else {
                rrQuality = '‚ùå Poor';
                rrColor = '#f31260';
            }
            
            document.getElementById('rrResults').innerHTML = `
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Risk/Reward</div>
                        <div class="metric-value">${rrRatio.toFixed(2)}:1</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Risk</div>
                        <div class="metric-value" style="color: #f31260;">$${risk.toFixed(2)}<br><span style="font-size: 14px;">(${riskPct.toFixed(2)}%)</span></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Reward</div>
                        <div class="metric-value" style="color: #00ff88;">$${reward.toFixed(2)}<br><span style="font-size: 14px;">(${rewardPct.toFixed(2)}%)</span></div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Quality</div>
                        <div class="metric-value" style="font-size: 18px; color: ${rrColor};">${rrQuality}</div>
                    </div>
                </div>
            `;
        }

        // Settings persistence
        function saveSettings() {
            const settings = {
                ticker: currentTicker,
                mode: document.querySelector('input[name="mode"]:checked').value,
                dataSource: document.getElementById('dataSource').value,
                apiKey: document.getElementById('apiKey').value,
                theme: document.querySelector('input[name="theme"]:checked').value,
                timeframe: document.getElementById('timeframe').value,
                periodDays: document.getElementById('periodDays').value,
                showSMA20: document.getElementById('showSMA20').checked,
                showSMA200: document.getElementById('showSMA200').checked,
                showEMA: document.getElementById('showEMA').checked,
                showVolume: document.getElementById('showVolume').checked,
                showRSI: document.getElementById('showRSI').checked,
                showMACD: document.getElementById('showMACD').checked,
                macdMode: document.querySelector('input[name="macdMode"]:checked').value,
                macdSidewaysWindow: document.getElementById('macdSidewaysWindow').value,
                macdSidewaysThreshold: document.getElementById('macdSidewaysThreshold').value,
                showBollinger: document.getElementById('showBollinger').checked,
                showSupertrend: document.getElementById('showSupertrend').checked,
                showFVG: document.getElementById('showFVG').checked
            };
            localStorage.setItem('traderqSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('traderqSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                if (settings.ticker) document.getElementById('tickerInput').value = settings.ticker;
                if (settings.mode) document.querySelector(`input[name="mode"][value="${settings.mode}"]`).checked = true;
                if (settings.dataSource) document.getElementById('dataSource').value = settings.dataSource;
                if (settings.apiKey) document.getElementById('apiKey').value = settings.apiKey;
                if (settings.theme) document.querySelector(`input[name="theme"][value="${settings.theme}"]`).checked = true;
                if (settings.timeframe) document.getElementById('timeframe').value = settings.timeframe;
                if (settings.periodDays) document.getElementById('periodDays').value = settings.periodDays;
                if (settings.showSMA20 !== undefined) document.getElementById('showSMA20').checked = settings.showSMA20;
                if (settings.showSMA200 !== undefined) document.getElementById('showSMA200').checked = settings.showSMA200;
                if (settings.showEMA !== undefined) document.getElementById('showEMA').checked = settings.showEMA;
                if (settings.showVolume !== undefined) document.getElementById('showVolume').checked = settings.showVolume;
                if (settings.showRSI !== undefined) document.getElementById('showRSI').checked = settings.showRSI;
                if (settings.showMACD !== undefined) document.getElementById('showMACD').checked = settings.showMACD;
                if (settings.macdMode) document.querySelector(`input[name="macdMode"][value="${settings.macdMode}"]`).checked = true;
                if (settings.macdSidewaysWindow) document.getElementById('macdSidewaysWindow').value = settings.macdSidewaysWindow;
                if (settings.macdSidewaysThreshold) document.getElementById('macdSidewaysThreshold').value = settings.macdSidewaysThreshold;
                if (settings.showBollinger !== undefined) document.getElementById('showBollinger').checked = settings.showBollinger;
                if (settings.showSupertrend !== undefined) document.getElementById('showSupertrend').checked = settings.showSupertrend;
                if (settings.showFVG !== undefined) document.getElementById('showFVG').checked = settings.showFVG;
            }
        }

        // Event listeners
        document.getElementById('showMACD').addEventListener('change', function() {
            document.getElementById('macdModeContainer').style.display = this.checked ? 'block' : 'none';
        });

        // Helper function to download text as file
        function downloadFile(filename, text, mimeType = 'text/plain') {
            const blob = new Blob([text], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Create server startup scripts
        function createServerScripts() {
            const htmlFileName = window.location.pathname.split('/').pop() || 'traderq.html';
            
            // Windows Batch file
            const batScript = `@echo off
echo Starting TraderQ Server...
echo.
echo Server will start at: http://localhost:8000/${htmlFileName}
echo.
echo Press Ctrl+C to stop the server
echo.
python -m http.server 8000
pause
`;

            // Mac/Linux Shell script
            const shScript = `#!/bin/bash
echo "Starting TraderQ Server..."
echo ""
echo "Server will start at: http://localhost:8000/${htmlFileName}"
echo ""
echo "Press Ctrl+C to stop the server"
echo ""
python3 -m http.server 8000
`;

            // Python server script (standalone)
            const pyScript = `#!/usr/bin/env python3
"""
TraderQ Server Startup Script
Automatically starts a local web server and opens the app in your browser
"""
import http.server
import socketserver
import webbrowser
import os
import sys

PORT = 8000
HTML_FILE = '${htmlFileName}'

class MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()

def main():
    # Check if HTML file exists
    if not os.path.exists(HTML_FILE):
        print(f"Error: {HTML_FILE} not found in current directory!")
        print(f"Current directory: {os.getcwd()}")
        sys.exit(1)
    
    try:
        with socketserver.TCPServer(("", PORT), MyHTTPRequestHandler) as httpd:
            url = f"http://localhost:{PORT}/{HTML_FILE}"
            print(f"Starting TraderQ Server...")
            print(f"Server running at: {url}")
            print(f"Press Ctrl+C to stop the server\\n")
            
            # Try to open browser (works on most systems)
            try:
                webbrowser.open(url)
            except:
                print(f"Please manually open: {url}")
            
            httpd.serve_forever()
    except OSError as e:
        if e.errno == 98 or e.errno == 48:  # Address already in use
            print(f"Error: Port {PORT} is already in use!")
            print("Please close the other application or change PORT in this script.")
        else:
            print(f"Error starting server: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\\n\\nServer stopped.")

if __name__ == "__main__":
    main()
`;

            return { batScript, shScript, pyScript };
        }

        // Getter functions for scripts (to avoid escaping issues)
        function getBatScript() {
            const htmlFileName = window.location.pathname.split('/').pop() || 'traderq.html';
            return `@echo off
echo ============================================
echo Starting TraderQ Server...
echo ============================================
echo.
echo Checking for Python...
python --version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Python is not installed or not in PATH!
    echo.
    echo Please install Python from: https://www.python.org/downloads/
    echo Make sure to check "Add Python to PATH" during installation.
    echo.
    pause
    exit /b 1
)
echo Python found!
echo.
echo Starting server at: http://localhost:8000/${htmlFileName}
echo.
echo IMPORTANT: Keep this window open while using the app!
echo Press Ctrl+C to stop the server
echo.
echo ============================================
echo.
cd /d "%~dp0"
python -m http.server 8000
if errorlevel 1 (
    echo.
    echo ERROR: Failed to start server!
    echo Possible reasons:
    echo - Port 8000 is already in use
    echo - Python is not installed correctly
    echo.
    echo Try: python3 -m http.server 8000
    echo Or use a different port: python -m http.server 8080
    echo.
    pause
)
`;
        }

        function getShScript() {
            const htmlFileName = window.location.pathname.split('/').pop() || 'traderq.html';
            return `#!/bin/bash
echo "Starting TraderQ Server..."
echo ""
echo "Server will start at: http://localhost:8000/${htmlFileName}"
echo ""
echo "Press Ctrl+C to stop the server"
echo ""
python3 -m http.server 8000
`;
        }

        function getInstallerScript() {
            const htmlFileName = window.location.pathname.split('/').pop() || 'traderq.html';
            return `@echo off
REM ============================================
REM TraderQ Installer Script
REM ============================================
echo.
echo ============================================
echo TraderQ Setup & Installer
echo ============================================
echo.
echo This script will:
echo 1. Check if Python is installed
echo 2. Create a launcher script
echo 3. Set up everything needed to run TraderQ
echo.
pause

REM Change to script directory
cd /d "%~dp0"

REM Check for Python
echo.
echo [1/3] Checking for Python...
python --version >nul 2>&1
if errorlevel 1 (
    echo.
    echo ‚ùå Python is NOT installed!
    echo.
    echo Python is required to run TraderQ.
    echo.
    echo Please install Python:
    echo 1. Go to: https://www.python.org/downloads/
    echo 2. Download Python 3.x (latest version)
    echo 3. During installation, CHECK "Add Python to PATH"
    echo 4. Run this installer again after installing Python
    echo.
    echo Opening Python download page...
    start https://www.python.org/downloads/
    echo.
    pause
    exit /b 1
)

for /f "tokens=2" %%i in ('python --version 2^>^&1') do set PYTHON_VERSION=%%i
echo ‚úÖ Python found! Version: %PYTHON_VERSION%
echo.

REM Check if HTML file exists
echo [2/3] Checking for traderq.html...
if not exist "${htmlFileName}" (
    echo.
    echo ‚ùå ERROR: ${htmlFileName} not found in current directory!
    echo.
    echo Please make sure ${htmlFileName} is in the same folder as this installer.
    echo Current directory: %CD%
    echo.
    pause
    exit /b 1
)
echo ‚úÖ ${htmlFileName} found!
echo.

REM Create launcher script
echo [3/3] Creating launcher script...
(
echo @echo off
echo cd /d "%%~dp0"
echo echo Starting TraderQ Server...
echo echo.
echo echo Server will be available at: http://localhost:8000/${htmlFileName}
echo echo.
echo echo IMPORTANT: Keep this window open while using TraderQ!
echo echo Press Ctrl+C to stop the server.
echo echo.
echo python -m http.server 8000
echo if errorlevel 1 (
echo     echo.
echo     echo ERROR: Server failed to start!
echo     echo Trying alternative port 8080...
echo     python -m http.server 8080
echo     if errorlevel 1 (
echo         echo.
echo         echo ERROR: Could not start server on port 8080 either.
echo         echo Please check if Python is installed correctly.
echo         pause
echo     )
echo )
) > "START_TRADERQ.bat"

echo ‚úÖ Launcher script created: START_TRADERQ.bat
echo.

REM Create desktop shortcut (optional)
echo.
echo ============================================
echo Installation Complete!
echo ============================================
echo.
echo ‚úÖ Setup successful!
echo.
echo To run TraderQ:
echo 1. Double-click "START_TRADERQ.bat" in this folder
echo 2. A server window will open - keep it open
echo 3. Your browser will open automatically, or go to:
echo    http://localhost:8000/${htmlFileName}
echo.
echo ============================================
echo.
echo Would you like to start TraderQ now? (Y/N)
set /p START_NOW="> "
if /i "%START_NOW%"=="Y" (
    echo.
    echo Starting TraderQ...
    start "" "START_TRADERQ.bat"
    timeout /t 2 >nul
    start http://localhost:8000/${htmlFileName}
    echo.
    echo TraderQ should be opening in your browser!
) else (
    echo.
    echo You can start TraderQ anytime by double-clicking "START_TRADERQ.bat"
)
echo.
pause
`;

        function getPyScript() {
            const htmlFileName = window.location.pathname.split('/').pop() || 'traderq.html';
            return `#!/usr/bin/env python3
"""
TraderQ Server Startup Script
Automatically starts a local web server and opens the app in your browser
"""
import http.server
import socketserver
import webbrowser
import os
import sys

PORT = 8000
HTML_FILE = '${htmlFileName}'

class MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()

def main():
    # Check if HTML file exists
    if not os.path.exists(HTML_FILE):
        print(f"Error: {HTML_FILE} not found in current directory!")
        print(f"Current directory: {os.getcwd()}")
        sys.exit(1)
    
    try:
        with socketserver.TCPServer(("", PORT), MyHTTPRequestHandler) as httpd:
            url = f"http://localhost:{PORT}/{HTML_FILE}"
            print(f"Starting TraderQ Server...")
            print(f"Server running at: {url}")
            print(f"Press Ctrl+C to stop the server\\n")
            
            # Try to open browser (works on most systems)
            try:
                webbrowser.open(url)
            except:
                print(f"Please manually open: {url}")
            
            httpd.serve_forever()
    except OSError as e:
        if e.errno == 98 or e.errno == 48:  # Address already in use
            print(f"Error: Port {PORT} is already in use!")
            print("Please close the other application or change PORT in this script.")
        else:
            print(f"Error starting server: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\\n\\nServer stopped.")

if __name__ == "__main__":
    main()
`;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            if (document.getElementById('showMACD').checked) {
                document.getElementById('macdModeContainer').style.display = 'block';
            }
            
            // Check if running from file:// and show server startup options
            if (window.location.protocol === 'file:') {
                const scripts = createServerScripts();
                const htmlFileName = window.location.pathname.split('/').pop() || 'traderq.html';
                const tabContent = document.getElementById('tabContent');
                
                tabContent.innerHTML = `
                    <div class="server-startup">
                        <h3>üöÄ Quick Start - Local Server Setup</h3>
                        <p style="margin-bottom: 15px;">This app needs to run on a web server. Choose the easiest option for your system:</p>
                        
                        <h4 style="color: #00ff88; margin-top: 20px; margin-bottom: 10px;">‚≠ê Option 1: Installer Script (Recommended - Easiest!)</h4>
                        <p style="margin-bottom: 10px;">Download and run the installer - it will check everything and set up TraderQ automatically:</p>
                        
                        <div style="margin: 15px 0;">
                            <button onclick="downloadFile('INSTALL_TRADERQ.bat', getInstallerScript(), 'text/plain');" class="download-btn" style="background: linear-gradient(90deg, #00ff88 0%, #00d4ff 100%); font-size: 16px; padding: 15px 25px;">üöÄ INSTALL TRADERQ (Windows)</button>
                        </div>
                        
                        <div class="code-block" style="background: rgba(0, 255, 136, 0.15); border-color: #00ff88;">
                            <strong>üìã What the installer does:</strong><br>
                            ‚úÖ Checks if Python is installed<br>
                            ‚úÖ Creates a launcher script (START_TRADERQ.bat)<br>
                            ‚úÖ Sets everything up automatically<br>
                            ‚úÖ Can start TraderQ for you when done<br><br>
                            <strong>Just double-click INSTALL_TRADERQ.bat and follow the prompts!</strong>
                        </div>
                        
                        <h4 style="color: #00d4ff; margin-top: 25px; margin-bottom: 10px;">Option 2: Quick Start Scripts (If installer doesn't work)</h4>
                        <p style="margin-bottom: 10px;">Download the appropriate script for your system, place it in the <strong>same folder</strong> as this HTML file, and run it:</p>
                        
                        <div style="margin: 15px 0;">
                            <button onclick="downloadFile('start-server.bat', getBatScript(), 'text/plain');" class="download-btn">üì• Windows (.bat)</button>
                            <button onclick="downloadFile('start-server.sh', getShScript(), 'text/plain');" class="download-btn">üì• Mac/Linux (.sh)</button>
                            <button onclick="downloadFile('start-server.py', getPyScript(), 'text/plain');" class="download-btn">üì• Python (.py)</button>
                        </div>
                        
                        <div class="code-block" style="background: rgba(0, 255, 136, 0.1); border-color: #00ff88;">
                            <strong>üìã Step-by-Step Instructions:</strong><br><br>
                            <strong>Windows:</strong><br>
                            1. Click "üì• Windows (.bat)" above to download<br>
                            2. Make sure the .bat file is in the same folder as traderq.html<br>
                            3. Double-click <code>start-server.bat</code><br>
                            4. A black window will open - <strong>keep it open</strong> (this is the server)<br>
                            5. Your browser should open automatically, or go to: <a href="http://localhost:8000/${htmlFileName}" target="_blank" style="color: #00ff88;">http://localhost:8000/${htmlFileName}</a><br><br>
                            <strong>Mac/Linux:</strong><br>
                            1. Click "üì• Mac/Linux (.sh)" above to download<br>
                            2. Open terminal in the folder with traderq.html<br>
                            3. Run: <code>chmod +x start-server.sh</code><br>
                            4. Run: <code>./start-server.sh</code><br>
                            5. Keep terminal open and browser will open automatically<br><br>
                            <strong>Python Script:</strong><br>
                            1. Click "üì• Python (.py)" above to download<br>
                            2. Open terminal/command prompt in the folder<br>
                            3. Run: <code>python start-server.py</code> (or <code>python3 start-server.py</code>)<br>
                            4. Keep terminal open - browser opens automatically
                        </div>
                        
                        <h4 style="color: #00d4ff; margin-top: 25px; margin-bottom: 10px;">Option 2: Manual Command (If scripts don't work)</h4>
                        <p style="margin-bottom: 10px;">Open terminal/command prompt in the folder with traderq.html and run:</p>
                        <div class="code-block">
                            <strong>Windows:</strong><br>
                            python -m http.server 8000<br><br>
                            <strong>Mac/Linux:</strong><br>
                            python3 -m http.server 8000
                        </div>
                        <p style="margin-top: 10px;"><strong>Important:</strong> Keep the terminal window open! The server runs in that window.</p>
                        <p style="margin-top: 10px;">Then manually open: <a href="http://localhost:8000/${htmlFileName}" target="_blank" style="color: #00d4ff; font-weight: bold;">http://localhost:8000/${htmlFileName}</a></p>
                        
                        <div style="margin-top: 20px; padding: 15px; background: rgba(243, 18, 96, 0.1); border-left: 3px solid #f31260; border-radius: 4px;">
                            <strong>‚ö†Ô∏è Troubleshooting "Cannot be reached" Error:</strong><br>
                            <ul style="margin-left: 20px; margin-top: 10px; line-height: 1.8;">
                                <li>Make sure the server is actually running (you should see a terminal/command window open)</li>
                                <li>Check that Python is installed: Open terminal and type <code>python --version</code> (or <code>python3 --version</code>)</li>
                                <li>Verify port 8000 is not in use (close other applications using it)</li>
                                <li>Make sure traderq.html is in the same folder where you started the server</li>
                                <li>Try a different port: <code>python -m http.server 8080</code> then go to <code>http://localhost:8080/${htmlFileName}</code></li>
                                <li>Check Windows Firewall isn't blocking Python</li>
                            </ul>
                        </div>
                        
                        <h4 style="color: #00d4ff; margin-top: 25px; margin-bottom: 10px;">Option 3: Use Alpha Vantage API (No server needed)</h4>
                        <p style="margin-bottom: 10px;">Switch to "Alpha Vantage" data source in the sidebar and get a free API key from <a href="https://www.alphavantage.co/support/#api-key" target="_blank" style="color: #00d4ff;">alphavantage.co</a></p>
                        <p style="margin-bottom: 10px; color: #888;">This works even without a local server, but requires an internet connection and API key.</p>
                    </div>
                    <div id="trackerTab">
                        <div class="chart-container" id="chart"></div>
                        <div class="metrics" id="metrics"></div>
                    </div>
                `;
            } else {
                // Only auto-load data if not from file:// protocol
                loadData();
            }
        });

        // Auto-save on changes
        document.querySelectorAll('input, select').forEach(el => {
            el.addEventListener('change', saveSettings);
        });

        // Re-render chart on indicator toggle
        document.querySelectorAll('#showSMA20, #showSMA200, #showEMA, #showVolume, #showRSI, #showMACD, #showBollinger, #showSupertrend, #showFVG, input[name="theme"], input[name="macdMode"], #macdSidewaysWindow, #macdSidewaysThreshold').forEach(el => {
            el.addEventListener('change', function() {
                if (currentData) {
                    renderChart();
                    saveSettings();
                }
            });
        });
    </script>
</body>
</html>

